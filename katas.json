{
  "katas": [
        {
      "title": "Add Two Numbers",
      "slug": "add-two-numbers",
      "description": "Return the sum of two integers.",
      "visible_skeleton": "func Add(a int, b int) int {\n    return 0\n}\n",
      "test_cases": [
        { "call": "Add(1, 2)", "expected": "3" },
        { "call": "Add(-2, 3)", "expected": "1" },
        { "call": "Add(0, 0)", "expected": "0" },
        { "call": "Add(100, 200)", "expected": "300" },
        { "call": "Add(-100, -100)", "expected": "-200" },
        { "call": "Add(2147483647, 1)", "expected": "2147483648" },
        { "call": "Add(-2147483648, 1)", "expected": "-2147483647" },
        { "call": "Add(999, -999)", "expected": "0" },
        { "call": "Add(5000, 0)", "expected": "5000" },
        { "call": "Add(0, 5000)", "expected": "5000" }
      ]
    },
    {
      "title": "Binary Search (Leftmost Index)",
      "slug": "binary-search-leftmost",
      "description": "Given a sorted slice of integers and a target, return the index of the leftmost occurrence of target, or -1 if not found.",
      "visible_skeleton": "func BinarySearchLeftmost(nums []int, target int) int {\n\t// return leftmost index of target or -1\n\treturn -1\n}\n",
      "test_cases": [
        {
          "call": "BinarySearchLeftmost([]int{1,3,5,7,9}, 1)",
          "expected": "0"
        },
        {
          "call": "BinarySearchLeftmost([]int{1,3,5,7,9}, 9)",
          "expected": "4"
        },
        {
          "call": "BinarySearchLeftmost([]int{1,3,5,7,9}, 4)",
          "expected": "-1"
        },
        {
          "call": "BinarySearchLeftmost([]int{}, 5)",
          "expected": "-1"
        },
        {
          "call": "BinarySearchLeftmost([]int{5}, 5)",
          "expected": "0"
        },
        {
          "call": "BinarySearchLeftmost([]int{5}, 3)",
          "expected": "-1"
        },
        {
          "call": "BinarySearchLeftmost([]int{2,2,2,2}, 2)",
          "expected": "0"
        },
        {
          "call": "BinarySearchLeftmost([]int{-5,-3,-1,0,2}, -3)",
          "expected": "1"
        },
        {
          "call": "BinarySearchLeftmost([]int{-5,-3,-1,0,2}, 2)",
          "expected": "4"
        },
        {
          "call": "BinarySearchLeftmost([]int{1,2,4,4,4,5}, 4)",
          "expected": "2"
        },
        {
          "call": "BinarySearchLeftmost([]int{1,2,3,4,5}, 6)",
          "expected": "-1"
        },
        {
          "call": "BinarySearchLeftmost([]int{1,2,3,4,5}, -1)",
          "expected": "-1"
        },
        {
          "call": "BinarySearchLeftmost([]int{0}, 0)",
          "expected": "0"
        },
        {
          "call": "BinarySearchLeftmost([]int{0,1}, 1)",
          "expected": "1"
        },
        {
          "call": "BinarySearchLeftmost([]int{0,1}, 0)",
          "expected": "0"
        },
        {
          "call": "BinarySearchLeftmost([]int{1,3,3,3,7}, 3)",
          "expected": "1"
        },
        {
          "call": "BinarySearchLeftmost([]int{1,3,5,7}, 6)",
          "expected": "-1"
        },
        {
          "call": "BinarySearchLeftmost([]int{10,20,30,40,50}, 40)",
          "expected": "3"
        },
        {
          "call": "BinarySearchLeftmost([]int{10,20,30,40,50}, 25)",
          "expected": "-1"
        },
        {
          "call": "BinarySearchLeftmost([]int{1,1,2,2,3,3}, 3)",
          "expected": "4"
        }
      ]
    },
    {
      "title": "Two Sum (Sorted, Two Pointers)",
      "slug": "two-sum-sorted",
      "description": "Given a sorted slice of integers and a target, return true if any two numbers sum to the target (using two pointers).",
      "visible_skeleton": "func TwoSumSorted(nums []int, target int) bool {\n\t// nums is sorted non-decreasing\n\treturn false\n}\n",
      "test_cases": [
        {
          "call": "TwoSumSorted([]int{1,2,3,4}, 5)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{1,2,3,4}, 7)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{1,2,3,4}, 8)",
          "expected": "false"
        },
        {
          "call": "TwoSumSorted([]int{}, 0)",
          "expected": "false"
        },
        {
          "call": "TwoSumSorted([]int{5}, 5)",
          "expected": "false"
        },
        {
          "call": "TwoSumSorted([]int{-3,-1,2,4}, 1)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{-3,-1,2,4}, 10)",
          "expected": "false"
        },
        {
          "call": "TwoSumSorted([]int{2,2}, 4)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{2,3,5,9}, 7)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{2,3,5,9}, 10)",
          "expected": "false"
        },
        {
          "call": "TwoSumSorted([]int{1,1,1,1}, 2)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{1,1,1,1}, 3)",
          "expected": "false"
        },
        {
          "call": "TwoSumSorted([]int{0,0,3,4}, 0)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{0,0,3,4}, 7)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{1,2,3,9}, 8)",
          "expected": "false"
        },
        {
          "call": "TwoSumSorted([]int{1,2,4,4}, 8)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{1,2,4,4}, 9)",
          "expected": "false"
        },
        {
          "call": "TwoSumSorted([]int{-5,-2,0,3,4}, -2)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{-5,-2,0,3,4}, -7)",
          "expected": "true"
        },
        {
          "call": "TwoSumSorted([]int{-5,-2,0,3,4}, -8)",
          "expected": "false"
        }
      ]
    },
    {
      "title": "Longest Substring Without Repeating Characters (Sliding Window)",
      "slug": "longest-substring-unique",
      "description": "Return the length of the longest substring without repeating characters using a sliding window.",
      "visible_skeleton": "func LengthOfLongestSubstring(s string) int {\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "LengthOfLongestSubstring(\"abcabcbb\")",
          "expected": "3"
        },
        {
          "call": "LengthOfLongestSubstring(\"bbbbb\")",
          "expected": "1"
        },
        {
          "call": "LengthOfLongestSubstring(\"pwwkew\")",
          "expected": "3"
        },
        {
          "call": "LengthOfLongestSubstring(\"\")",
          "expected": "0"
        },
        {
          "call": "LengthOfLongestSubstring(\"a\")",
          "expected": "1"
        },
        {
          "call": "LengthOfLongestSubstring(\"au\")",
          "expected": "2"
        },
        {
          "call": "LengthOfLongestSubstring(\"dvdf\")",
          "expected": "3"
        },
        {
          "call": "LengthOfLongestSubstring(\"abba\")",
          "expected": "2"
        },
        {
          "call": "LengthOfLongestSubstring(\"tmmzuxt\")",
          "expected": "5"
        },
        {
          "call": "LengthOfLongestSubstring(\"anviaj\")",
          "expected": "5"
        },
        {
          "call": "LengthOfLongestSubstring(\"abcadefg\")",
          "expected": "7"
        },
        {
          "call": "LengthOfLongestSubstring(\"abcdef\")",
          "expected": "6"
        },
        {
          "call": "LengthOfLongestSubstring(\"aaab\")",
          "expected": "2"
        },
        {
          "call": "LengthOfLongestSubstring(\"abcabcde\")",
          "expected": "5"
        },
        {
          "call": "LengthOfLongestSubstring(\"長短長短\")",
          "expected": "2"
        },
        {
          "call": "LengthOfLongestSubstring(\"abbaabcd\")",
          "expected": "4"
        },
        {
          "call": "LengthOfLongestSubstring(\"abccdef\")",
          "expected": "4"
        },
        {
          "call": "LengthOfLongestSubstring(\"aa\")",
          "expected": "1"
        },
        {
          "call": "LengthOfLongestSubstring(\"aab\")",
          "expected": "2"
        },
        {
          "call": "LengthOfLongestSubstring(\"aba\")",
          "expected": "2"
        }
      ]
    },
    {
      "title": "Climbing Stairs (DP Top-Down with Memoization)",
      "slug": "climb-stairs-memo",
      "description": "You can climb 1 or 2 steps. Return the number of distinct ways to reach step n. Assume ways(0)=1, ways(1)=1.",
      "visible_skeleton": "func ClimbStairsMemo(n int) int {\n\t// use recursion + memo (top-down)\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "ClimbStairsMemo(0)",
          "expected": "1"
        },
        {
          "call": "ClimbStairsMemo(1)",
          "expected": "1"
        },
        {
          "call": "ClimbStairsMemo(2)",
          "expected": "2"
        },
        {
          "call": "ClimbStairsMemo(3)",
          "expected": "3"
        },
        {
          "call": "ClimbStairsMemo(4)",
          "expected": "5"
        },
        {
          "call": "ClimbStairsMemo(5)",
          "expected": "8"
        },
        {
          "call": "ClimbStairsMemo(6)",
          "expected": "13"
        },
        {
          "call": "ClimbStairsMemo(7)",
          "expected": "21"
        },
        {
          "call": "ClimbStairsMemo(8)",
          "expected": "34"
        },
        {
          "call": "ClimbStairsMemo(9)",
          "expected": "55"
        },
        {
          "call": "ClimbStairsMemo(10)",
          "expected": "89"
        },
        {
          "call": "ClimbStairsMemo(11)",
          "expected": "144"
        },
        {
          "call": "ClimbStairsMemo(12)",
          "expected": "233"
        },
        {
          "call": "ClimbStairsMemo(13)",
          "expected": "377"
        },
        {
          "call": "ClimbStairsMemo(14)",
          "expected": "610"
        },
        {
          "call": "ClimbStairsMemo(15)",
          "expected": "987"
        },
        {
          "call": "ClimbStairsMemo(16)",
          "expected": "1597"
        },
        {
          "call": "ClimbStairsMemo(17)",
          "expected": "2584"
        },
        {
          "call": "ClimbStairsMemo(18)",
          "expected": "4181"
        },
        {
          "call": "ClimbStairsMemo(19)",
          "expected": "6765"
        }
      ]
    },
    {
      "title": "Quickselect (k-th Smallest)",
      "slug": "quickselect-kth",
      "description": "Return the k-th smallest element (1-indexed) in an unsorted slice using Quickselect.",
      "visible_skeleton": "func KthSmallest(nums []int, k int) int {\n\t// 1 <= k <= len(nums)\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "KthSmallest([]int{3,1,2}, 1)",
          "expected": "1"
        },
        {
          "call": "KthSmallest([]int{3,1,2}, 2)",
          "expected": "2"
        },
        {
          "call": "KthSmallest([]int{3,1,2}, 3)",
          "expected": "3"
        },
        {
          "call": "KthSmallest([]int{7,10,4,3,20,15}, 3)",
          "expected": "7"
        },
        {
          "call": "KthSmallest([]int{7,10,4,3,20,15}, 4)",
          "expected": "10"
        },
        {
          "call": "KthSmallest([]int{1,1,1}, 2)",
          "expected": "1"
        },
        {
          "call": "KthSmallest([]int{5}, 1)",
          "expected": "5"
        },
        {
          "call": "KthSmallest([]int{-1,-3,-2}, 2)",
          "expected": "-2"
        },
        {
          "call": "KthSmallest([]int{2,2,3,1}, 3)",
          "expected": "2"
        },
        {
          "call": "KthSmallest([]int{9,8,7,6,5,4,3,2,1}, 5)",
          "expected": "5"
        },
        {
          "call": "KthSmallest([]int{100,200,50,50}, 2)",
          "expected": "50"
        },
        {
          "call": "KthSmallest([]int{100,200,50,50}, 3)",
          "expected": "100"
        },
        {
          "call": "KthSmallest([]int{0,0,0,0}, 4)",
          "expected": "0"
        },
        {
          "call": "KthSmallest([]int{1,2,2,2,3}, 4)",
          "expected": "2"
        },
        {
          "call": "KthSmallest([]int{-5,-1,-3,-4}, 1)",
          "expected": "-5"
        },
        {
          "call": "KthSmallest([]int{8,8,8,9,9}, 5)",
          "expected": "9"
        },
        {
          "call": "KthSmallest([]int{8,8,8,9,9}, 4)",
          "expected": "9"
        },
        {
          "call": "KthSmallest([]int{2,1}, 2)",
          "expected": "2"
        },
        {
          "call": "KthSmallest([]int{2,1}, 1)",
          "expected": "1"
        },
        {
          "call": "KthSmallest([]int{3,3,3,3,2}, 2)",
          "expected": "3"
        }
      ]
    },
    {
      "title": "Union Find (Count Connected Components)",
      "slug": "union-find-count-components",
      "description": "Given n nodes labeled 0..n-1 and an edge list for an undirected graph, return the number of connected components using Union-Find (Disjoint Set Union).",
      "visible_skeleton": "func CountComponents(n int, edges [][]int) int {\n\t// DSU / Union-Find\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "CountComponents(5, [][]int{{0,1},{1,2},{3,4}})",
          "expected": "2"
        },
        {
          "call": "CountComponents(5, [][]int{})",
          "expected": "5"
        },
        {
          "call": "CountComponents(1, [][]int{})",
          "expected": "1"
        },
        {
          "call": "CountComponents(2, [][]int{{0,1}})",
          "expected": "1"
        },
        {
          "call": "CountComponents(4, [][]int{{0,1},{2,3}})",
          "expected": "2"
        },
        {
          "call": "CountComponents(4, [][]int{{0,1},{1,2},{2,3}})",
          "expected": "1"
        },
        {
          "call": "CountComponents(3, [][]int{{0,0}})",
          "expected": "2"
        },
        {
          "call": "CountComponents(3, [][]int{{0,1},{1,2},{0,2}})",
          "expected": "1"
        },
        {
          "call": "CountComponents(6, [][]int{{0,1},{2,3},{4,5}})",
          "expected": "3"
        },
        {
          "call": "CountComponents(6, [][]int{{0,1},{1,2},{3,4}})",
          "expected": "2"
        },
        {
          "call": "CountComponents(3, [][]int{})",
          "expected": "3"
        },
        {
          "call": "CountComponents(7, [][]int{{0,1},{1,2},{3,4},{5,6}})",
          "expected": "3"
        },
        {
          "call": "CountComponents(7, [][]int{{0,1},{2,3},{4,5}})",
          "expected": "4"
        },
        {
          "call": "CountComponents(2, [][]int{{0,1},{0,1}})",
          "expected": "1"
        },
        {
          "call": "CountComponents(5, [][]int{{0,1},{2,2}})",
          "expected": "4"
        },
        {
          "call": "CountComponents(5, [][]int{{1,2},{3,4}})",
          "expected": "3"
        },
        {
          "call": "CountComponents(3, [][]int{{0,2}})",
          "expected": "2"
        },
        {
          "call": "CountComponents(10, [][]int{})",
          "expected": "10"
        },
        {
          "call": "CountComponents(4, [][]int{{1,1},{2,2},{3,3}})",
          "expected": "4"
        },
        {
          "call": "CountComponents(4, [][]int{{0,1},{1,1},{1,2}})",
          "expected": "2"
        }
      ]
    },
    {
      "title": "LRU Cache (Functional Simulation)",
      "slug": "lru-cache-functional",
      "description": "Simulate an LRU cache. Perform ops (\"put\" or \"get\") with keys/values under capacity, then return Get(finalKey) after all ops. A missing key returns -1.",
      "visible_skeleton": "func LRUGetAfterOps(capacity int, ops []string, keys []int, vals []int, finalKey int) int {\n\t// simulate LRU; ops[i] is \"put\" or \"get\"; for \"get\" use keys[i]; for \"put\" use keys[i], vals[i]\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"put\"}, []int{1,2}, []int{1,2}, 1)",
          "expected": "1"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"put\",\"put\"}, []int{1,2,3}, []int{1,2,3}, 1)",
          "expected": "-1"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"put\",\"get\",\"put\"}, []int{1,2,1,3}, []int{1,2,0,3}, 2)",
          "expected": "-1"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"put\",\"get\",\"put\",\"get\"}, []int{1,2,1,3,3}, []int{1,2,0,3,0}, 1)",
          "expected": "1"
        },
        {
          "call": "LRUGetAfterOps(1, []string{\"put\",\"put\"}, []int{1,2}, []int{1,2}, 1)",
          "expected": "-1"
        },
        {
          "call": "LRUGetAfterOps(1, []string{\"put\",\"get\",\"put\",\"get\"}, []int{1,1,2,1}, []int{1,0,2,0}, 2)",
          "expected": "2"
        },
        {
          "call": "LRUGetAfterOps(3, []string{\"put\",\"put\",\"put\"}, []int{1,2,3}, []int{10,20,30}, 2)",
          "expected": "20"
        },
        {
          "call": "LRUGetAfterOps(3, []string{\"put\",\"put\",\"put\",\"get\",\"put\"}, []int{1,2,3,2,4}, []int{10,20,30,0,40}, 1)",
          "expected": "-1"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"get\",\"put\",\"get\"}, []int{1,1,2,1}, []int{5,0,6,0}, 1)",
          "expected": "1"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"get\",\"put\",\"get\",\"get\"}, []int{1,1,2,1,2}, []int{5,0,6,0,0}, 2)",
          "expected": "2"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"put\",\"get\",\"put\",\"get\"}, []int{1,2,2,3,2}, []int{1,2,0,3,0}, 2)",
          "expected": "2"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"put\",\"get\",\"put\",\"get\"}, []int{1,2,1,3,1}, []int{1,2,0,3,0}, 2)",
          "expected": "-1"
        },
        {
          "call": "LRUGetAfterOps(3, []string{\"put\",\"put\",\"put\",\"get\",\"put\",\"get\"}, []int{1,2,3,1,4,2}, []int{1,2,3,0,4,0}, 3)",
          "expected": "3"
        },
        {
          "call": "LRUGetAfterOps(3, []string{\"put\",\"put\",\"get\",\"put\",\"put\"}, []int{1,2,1,3,4}, []int{1,2,0,3,4}, 2)",
          "expected": "2"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"put\",\"get\",\"put\",\"get\",\"get\"}, []int{2,1,2,3,2,3}, []int{2,1,0,3,0,0}, 1)",
          "expected": "-1"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"put\",\"get\",\"get\"}, []int{2,2,2,2}, []int{2,0,0,0}, 2)",
          "expected": "2"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"get\",\"put\",\"put\",\"get\"}, []int{1,1,2,3,2}, []int{1,0,2,3,0}, 1)",
          "expected": "-1"
        },
        {
          "call": "LRUGetAfterOps(2, []string{\"put\",\"get\",\"put\",\"put\",\"get\"}, []int{1,1,2,1,2}, []int{1,0,2,10,0}, 1)",
          "expected": "10"
        },
        {
          "call": "LRUGetAfterOps(3, []string{\"put\",\"put\",\"put\",\"get\",\"put\",\"get\",\"get\"}, []int{1,2,3,2,4,3,4}, []int{1,2,3,0,4,0,0}, 1)",
          "expected": "-1"
        },
        {
          "call": "LRUGetAfterOps(3, []string{\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\"}, []int{1,2,1,3,2,4,4}, []int{7,8,0,9,0,10,0}, 3)",
          "expected": "9"
        }
      ]
    },
    {
      "title": "BFS Shortest Path in Grid (4-dir, 0 = free, 1 = wall)",
      "slug": "bfs-shortest-path-grid",
      "description": "Given a 0/1 grid, find the shortest path length from (0,0) to (n-1,m-1) moving up/down/left/right through 0-cells only. Return -1 if unreachable. Count the starting cell as step 1.",
      "visible_skeleton": "func ShortestPathGrid(grid [][]int) int {\n\t// BFS from (0,0) to (n-1,m-1); 4-directional; 0=free, 1=wall; return steps or -1\n\treturn -1\n}\n",
      "test_cases": [
        {
          "call": "ShortestPathGrid([][]int{{0}})",
          "expected": "1"
        },
        {
          "call": "ShortestPathGrid([][]int{{1}})",
          "expected": "-1"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0},{0,0}})",
          "expected": "3"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,1},{0,0}})",
          "expected": "3"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,1},{1,0}})",
          "expected": "-1"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0,0},{1,1,0},{0,0,0}})",
          "expected": "5"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,1,0},{0,1,0},{0,0,0}})",
          "expected": "5"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0,1},{1,0,1},{1,0,0}})",
          "expected": "5"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0,1,0},{1,0,0,0},{1,1,1,0},{0,0,0,0}})",
          "expected": "7"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,1,1,1},{0,0,0,1},{1,1,0,0},{1,1,1,0}})",
          "expected": "7"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0},{1,1}})",
          "expected": "-1"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0,0,0}})",
          "expected": "4"
        },
        {
          "call": "ShortestPathGrid([][]int{{0},{0},{0},{0}})",
          "expected": "4"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,1,0,0},{0,1,0,1},{0,0,0,1},{1,1,0,0}})",
          "expected": "7"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0,0},{0,1,0},{0,0,0}})",
          "expected": "5"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,1,1},{0,1,1},{0,0,0}})",
          "expected": "5"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0,1},{0,0,1},{1,0,0}})",
          "expected": "5"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0,0},{1,1,0},{1,1,0}})",
          "expected": "5"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,1,1,1,1},{0,0,0,0,1},{1,1,1,0,1},{1,1,1,0,0}})",
          "expected": "8"
        },
        {
          "call": "ShortestPathGrid([][]int{{0,0,1},{1,0,1},{1,0,1}})",
          "expected": "-1"
        }
      ]
    },
    {
      "title": "Backtracking: Count Subsets That Sum to Target",
      "slug": "subset-sum-count",
      "description": "Return the number of subsets of nums whose elements sum to target. Use backtracking (DFS) with/without pruning.",
      "visible_skeleton": "func CountSubsetsSum(nums []int, target int) int {\n\t// count subsets summing to target\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "CountSubsetsSum([]int{}, 0)",
          "expected": "1"
        },
        {
          "call": "CountSubsetsSum([]int{}, 5)",
          "expected": "0"
        },
        {
          "call": "CountSubsetsSum([]int{1}, 1)",
          "expected": "1"
        },
        {
          "call": "CountSubsetsSum([]int{1}, 0)",
          "expected": "1"
        },
        {
          "call": "CountSubsetsSum([]int{1,2,3}, 3)",
          "expected": "2"
        },
        {
          "call": "CountSubsetsSum([]int{1,2,3}, 4)",
          "expected": "1"
        },
        {
          "call": "CountSubsetsSum([]int{2,2,2}, 4)",
          "expected": "3"
        },
        {
          "call": "CountSubsetsSum([]int{2,3,5}, 10)",
          "expected": "1"
        },
        {
          "call": "CountSubsetsSum([]int{2,3,5}, 0)",
          "expected": "1"
        },
        {
          "call": "CountSubsetsSum([]int{-1,1}, 0)",
          "expected": "2"
        },
        {
          "call": "CountSubsetsSum([]int{-1,-1,2}, 0)",
          "expected": "2"
        },
        {
          "call": "CountSubsetsSum([]int{1,1,1,1}, 2)",
          "expected": "6"
        },
        {
          "call": "CountSubsetsSum([]int{1,2,2,3}, 5)",
          "expected": "3"
        },
        {
          "call": "CountSubsetsSum([]int{3,3,3}, 3)",
          "expected": "3"
        },
        {
          "call": "CountSubsetsSum([]int{3,3,3}, 6)",
          "expected": "3"
        },
        {
          "call": "CountSubsetsSum([]int{0,0,1}, 1)",
          "expected": "4"
        },
        {
          "call": "CountSubsetsSum([]int{0,0,0}, 0)",
          "expected": "8"
        },
        {
          "call": "CountSubsetsSum([]int{5, -2, 7}, 5)",
          "expected": "2"
        },
        {
          "call": "CountSubsetsSum([]int{1,2,3,4}, 6)",
          "expected": "2"
        },
        {
          "call": "CountSubsetsSum([]int{1,2,3,4}, 10)",
          "expected": "1"
        }
      ]
    },
    {
      "title": "Heap: Minimum Meeting Rooms",
      "slug": "min-meeting-rooms",
      "description": "Given intervals [start,end) for meetings, return the minimum number of meeting rooms required.",
      "visible_skeleton": "func MinMeetingRooms(intervals [][]int) int {\n\t// use a min-heap of end times\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "MinMeetingRooms([][]int{})",
          "expected": "0"
        },
        {
          "call": "MinMeetingRooms([][]int{{0,30},{5,10},{15,20}})",
          "expected": "2"
        },
        {
          "call": "MinMeetingRooms([][]int{{7,10},{2,4}})",
          "expected": "1"
        },
        {
          "call": "MinMeetingRooms([][]int{{1,5},{5,10}})",
          "expected": "1"
        },
        {
          "call": "MinMeetingRooms([][]int{{1,5},{2,3},{3,4}})",
          "expected": "2"
        },
        {
          "call": "MinMeetingRooms([][]int{{1,10},{2,7},{3,19},{8,12},{10,20},{11,30}})",
          "expected": "4"
        },
        {
          "call": "MinMeetingRooms([][]int{{0,1}})",
          "expected": "1"
        },
        {
          "call": "MinMeetingRooms([][]int{{0,5},{6,10},{11,15}})",
          "expected": "1"
        },
        {
          "call": "MinMeetingRooms([][]int{{0,5},{4,10},{9,12}})",
          "expected": "2"
        },
        {
          "call": "MinMeetingRooms([][]int{{2,3},{3,4},{4,5},{5,6}})",
          "expected": "1"
        },
        {
          "call": "MinMeetingRooms([][]int{{1,4},{2,5},{7,9}})",
          "expected": "2"
        },
        {
          "call": "MinMeetingRooms([][]int{{1,4},{4,5},{5,6}})",
          "expected": "1"
        },
        {
          "call": "MinMeetingRooms([][]int{{1,10},{2,3},{3,4},{4,5},{5,6}})",
          "expected": "2"
        },
        {
          "call": "MinMeetingRooms([][]int{{5,10},{6,8},{1,5}})",
          "expected": "2"
        },
        {
          "call": "MinMeetingRooms([][]int{{1,2},{1,2},{1,2}})",
          "expected": "3"
        },
        {
          "call": "MinMeetingRooms([][]int{{1,3},{2,6},{4,5}})",
          "expected": "2"
        },
        {
          "call": "MinMeetingRooms([][]int{{13,15},{1,13}})",
          "expected": "1"
        },
        {
          "call": "MinMeetingRooms([][]int{{0,10},{10,20},{20,30}})",
          "expected": "1"
        },
        {
          "call": "MinMeetingRooms([][]int{{0,10},{5,15},{10,20}})",
          "expected": "2"
        },
        {
          "call": "MinMeetingRooms([][]int{{0,30},{30,60},{15,45}})",
          "expected": "2"
        }
      ]
    },
    {
      "title": "Intervals: Merge and Count",
      "slug": "merge-intervals-count",
      "description": "Given intervals, merge all overlapping intervals and return the number of merged intervals.",
      "visible_skeleton": "func MergeIntervalsCount(intervals [][]int) int {\n\t// sort by start, merge, return count\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "MergeIntervalsCount([][]int{})",
          "expected": "0"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,3}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,3},{2,6},{8,10},{15,18}})",
          "expected": "3"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,4},{4,5}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,4},{5,6}})",
          "expected": "2"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,10},{2,3},{4,5}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{6,8},{1,9},{2,4},{4,7}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,2},{3,4},{5,6}})",
          "expected": "3"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,5},{2,3}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,5},{5,7},{7,9}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,5},{2,6},{7,9}})",
          "expected": "2"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,5},{0,0}})",
          "expected": "2"
        },
        {
          "call": "MergeIntervalsCount([][]int{{0,0},{0,0}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{-3,-1},{-2,2},{3,4}})",
          "expected": "2"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,4},{2,3},{3,6}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,4},{0,2},{3,5}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,2},{2,3}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,2},{2,3},{4,5},{6,7}})",
          "expected": "3"
        },
        {
          "call": "MergeIntervalsCount([][]int{{1,100},{2,99},{3,98}})",
          "expected": "1"
        },
        {
          "call": "MergeIntervalsCount([][]int{{5,6},{1,2},{3,4},{7,8}})",
          "expected": "4"
        }
      ]
    },
    {
      "title": "Stacks: Valid Parentheses",
      "slug": "valid-parentheses",
      "description": "Given a string with '()[]{}', return true if it is valid (properly closed & nested).",
      "visible_skeleton": "func IsValidParens(s string) bool {\n\t// use a stack\n\treturn false\n}\n",
      "test_cases": [
        {
          "call": "IsValidParens(\"\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"()\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"()[]{}\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"(]\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\"([)]\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\"{[]}\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"(\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\")\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\"([])\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"([]{}{})\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"([{}])\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"([{}]))\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\"((((()))))\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"((((())))\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\"[]{}(\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\"[{}](())\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"[{}](()\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\"{}[]{}[]\")",
          "expected": "true"
        },
        {
          "call": "IsValidParens(\"{[}\")",
          "expected": "false"
        },
        {
          "call": "IsValidParens(\"[{()}](){}\")",
          "expected": "true"
        }
      ]
    },
    {
      "title": "Trie: Count Words Starting With Prefix",
      "slug": "trie-count-prefix",
      "description": "Given a list of lowercase words and a prefix, return the count of words that start with the prefix. (Implement efficiently with a Trie.)",
      "visible_skeleton": "func CountPrefix(words []string, prefix string) int {\n\t// return number of words beginning with prefix\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "CountPrefix([]string{}, \"a\")",
          "expected": "0"
        },
        {
          "call": "CountPrefix([]string{\"a\"}, \"a\")",
          "expected": "1"
        },
        {
          "call": "CountPrefix([]string{\"a\"}, \"b\")",
          "expected": "0"
        },
        {
          "call": "CountPrefix([]string{\"apple\",\"app\",\"apex\"}, \"ap\")",
          "expected": "3"
        },
        {
          "call": "CountPrefix([]string{\"apple\",\"app\",\"apex\"}, \"app\")",
          "expected": "2"
        },
        {
          "call": "CountPrefix([]string{\"apple\",\"banana\",\"band\",\"bandana\"}, \"ban\")",
          "expected": "3"
        },
        {
          "call": "CountPrefix([]string{\"dog\",\"deer\",\"deal\"}, \"de\")",
          "expected": "2"
        },
        {
          "call": "CountPrefix([]string{\"dog\",\"deer\",\"deal\"}, \"d\")",
          "expected": "3"
        },
        {
          "call": "CountPrefix([]string{\"x\",\"xy\",\"xyz\"}, \"xy\")",
          "expected": "2"
        },
        {
          "call": "CountPrefix([]string{\"test\",\"testing\",\"tester\"}, \"testi\")",
          "expected": "1"
        },
        {
          "call": "CountPrefix([]string{\"aa\",\"aaa\",\"aaaa\"}, \"a\")",
          "expected": "3"
        },
        {
          "call": "CountPrefix([]string{\"aa\",\"aaa\",\"aaaa\"}, \"aa\")",
          "expected": "3"
        },
        {
          "call": "CountPrefix([]string{\"aa\",\"aaa\",\"aaaa\"}, \"aaaaa\")",
          "expected": "0"
        },
        {
          "call": "CountPrefix([]string{\"cat\",\"car\",\"cart\",\"dog\"}, \"car\")",
          "expected": "2"
        },
        {
          "call": "CountPrefix([]string{\"cat\",\"car\",\"cart\",\"dog\"}, \"cart\")",
          "expected": "1"
        },
        {
          "call": "CountPrefix([]string{\"home\",\"house\",\"hover\"}, \"ho\")",
          "expected": "3"
        },
        {
          "call": "CountPrefix([]string{\"home\",\"house\",\"hover\"}, \"hou\")",
          "expected": "1"
        },
        {
          "call": "CountPrefix([]string{\"\",\"a\",\"ab\"}, \"\")",
          "expected": "3"
        },
        {
          "call": "CountPrefix([]string{\"z\",\"zz\",\"zzz\"}, \"zz\")",
          "expected": "2"
        },
        {
          "call": "CountPrefix([]string{\"alpha\",\"beta\",\"gamma\"}, \"delta\")",
          "expected": "0"
        }
      ]
    },
    {
      "title": "Dijkstra: Shortest Path Distance in Weighted Graph",
      "slug": "dijkstra-shortest-distance",
      "description": "Given n nodes labeled 0..n-1 and weighted undirected edges [[u,v,w]], return shortest distance from src to dst, or -1 if unreachable.",
      "visible_skeleton": "func ShortestDistance(n int, edges [][]int, src int, dst int) int {\n\t// Dijkstra with min-heap\n\treturn -1\n}\n",
      "test_cases": [
        {
          "call": "ShortestDistance(1, [][]int{}, 0, 0)",
          "expected": "0"
        },
        {
          "call": "ShortestDistance(2, [][]int{{0,1,5}}, 0, 1)",
          "expected": "5"
        },
        {
          "call": "ShortestDistance(2, [][]int{{0,1,5}}, 1, 0)",
          "expected": "5"
        },
        {
          "call": "ShortestDistance(3, [][]int{{0,1,2},{1,2,2},{0,2,5}}, 0, 2)",
          "expected": "4"
        },
        {
          "call": "ShortestDistance(3, [][]int{{0,1,2},{1,2,2}}, 2, 0)",
          "expected": "4"
        },
        {
          "call": "ShortestDistance(3, [][]int{{0,1,10}}, 0, 2)",
          "expected": "-1"
        },
        {
          "call": "ShortestDistance(4, [][]int{{0,1,1},{1,2,1},{2,3,1},{0,3,10}}, 0, 3)",
          "expected": "3"
        },
        {
          "call": "ShortestDistance(4, [][]int{{0,1,3},{1,2,4},{0,2,10},{2,3,1}}, 0, 3)",
          "expected": "8"
        },
        {
          "call": "ShortestDistance(5, [][]int{{0,1,2},{1,2,2},{2,3,2},{3,4,2}}, 0, 4)",
          "expected": "8"
        },
        {
          "call": "ShortestDistance(5, [][]int{{0,1,2},{0,2,2},{1,3,3},{2,3,1},{3,4,1}}, 0, 4)",
          "expected": "4"
        },
        {
          "call": "ShortestDistance(3, [][]int{{0,1,1},{1,2,1},{0,2,3}}, 0, 2)",
          "expected": "2"
        },
        {
          "call": "ShortestDistance(3, [][]int{{0,1,100},{1,2,1},{0,2,50}}, 0, 2)",
          "expected": "50"
        },
        {
          "call": "ShortestDistance(3, [][]int{{0,1,100},{1,2,1}}, 0, 2)",
          "expected": "101"
        },
        {
          "call": "ShortestDistance(6, [][]int{{0,1,7},{0,2,9},{0,5,14},{1,2,10},{1,3,15},{2,3,11},{2,5,2},{3,4,6},{4,5,9}}, 0, 4)",
          "expected": "20"
        },
        {
          "call": "ShortestDistance(4, [][]int{{0,1,2},{1,3,2},{0,2,2},{2,3,2}}, 0, 3)",
          "expected": "4"
        },
        {
          "call": "ShortestDistance(4, [][]int{{0,1,5},{1,2,5}}, 0, 3)",
          "expected": "-1"
        },
        {
          "call": "ShortestDistance(2, [][]int{}, 0, 1)",
          "expected": "-1"
        },
        {
          "call": "ShortestDistance(5, [][]int{{0,1,1},{1,2,1},{2,3,1},{3,4,1},{0,4,10}}, 0, 4)",
          "expected": "4"
        },
        {
          "call": "ShortestDistance(5, [][]int{{0,1,1},{1,2,100},{0,2,2}}, 0, 2)",
          "expected": "2"
        }
      ]
    },
    {
      "title": "Prefix Sums: Count Subarrays With Sum = k",
      "slug": "subarray-sum-equals-k-count",
      "description": "Given nums and integer k, return the number of continuous subarrays whose sum equals k. Use prefix-sum + hash map.",
      "visible_skeleton": "func SubarraySumCount(nums []int, k int) int {\n\t// prefix sum + hashmap of counts\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "SubarraySumCount([]int{}, 0)",
          "expected": "0"
        },
        {
          "call": "SubarraySumCount([]int{1}, 1)",
          "expected": "1"
        },
        {
          "call": "SubarraySumCount([]int{1}, 0)",
          "expected": "0"
        },
        {
          "call": "SubarraySumCount([]int{1,1,1}, 2)",
          "expected": "2"
        },
        {
          "call": "SubarraySumCount([]int{1,2,3}, 3)",
          "expected": "2"
        },
        {
          "call": "SubarraySumCount([]int{1,2,3}, 6)",
          "expected": "1"
        },
        {
          "call": "SubarraySumCount([]int{1,2,3}, 7)",
          "expected": "0"
        },
        {
          "call": "SubarraySumCount([]int{-1,1,0}, 0)",
          "expected": "3"
        },
        {
          "call": "SubarraySumCount([]int{0,0,0}, 0)",
          "expected": "6"
        },
        {
          "call": "SubarraySumCount([]int{3,4,7,2,-3,1,4,2}, 7)",
          "expected": "4"
        },
        {
          "call": "SubarraySumCount([]int{2,-2,2,-2}, 0)",
          "expected": "6"
        },
        {
          "call": "SubarraySumCount([]int{-1,-1,1}, 0)",
          "expected": "1"
        },
        {
          "call": "SubarraySumCount([]int{1,-1,1,-1}, 0)",
          "expected": "4"
        },
        {
          "call": "SubarraySumCount([]int{1,2,1,2,1}, 3)",
          "expected": "4"
        },
        {
          "call": "SubarraySumCount([]int{5}, 5)",
          "expected": "1"
        },
        {
          "call": "SubarraySumCount([]int{5}, 0)",
          "expected": "0"
        },
        {
          "call": "SubarraySumCount([]int{0}, 0)",
          "expected": "1"
        },
        {
          "call": "SubarraySumCount([]int{0,1,0,1,0}, 1)",
          "expected": "6"
        },
        {
          "call": "SubarraySumCount([]int{1,2,-2,2,-1}, 2)",
          "expected": "4"
        },
        {
          "call": "SubarraySumCount([]int{2,2,2}, 2)",
          "expected": "3"
        }
      ]
    },
    {
      "title": "Greedy: Max Non-Overlapping Intervals",
      "slug": "greedy-interval-scheduling",
      "description": "Given intervals [start,end), select the maximum number of non-overlapping intervals. Return that maximum count.",
      "visible_skeleton": "func MaxNonOverlapping(intervals [][]int) int {\n\t// greedy by earliest end time\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "MaxNonOverlapping([][]int{})",
          "expected": "0"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,2}})",
          "expected": "1"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,2},{2,3}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,3},{2,4},{3,5}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,4},{2,3},{3,5},{0,7},{5,6}})",
          "expected": "3"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,10},{2,3},{3,4},{4,5}})",
          "expected": "3"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,5},{1,5},{1,5}})",
          "expected": "1"
        },
        {
          "call": "MaxNonOverlapping([][]int{{0,1},{1,2},{2,3},{3,4}})",
          "expected": "4"
        },
        {
          "call": "MaxNonOverlapping([][]int{{0,3},{1,2},{2,3}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{0,3},{3,6},{6,9}})",
          "expected": "3"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,2},{2,3},{2,4}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,3},{3,3}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{-2,-1},{-1,0},{0,1}})",
          "expected": "3"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,3},{2,2}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,100},{50,60},{60,70},{70,80}})",
          "expected": "3"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,2},{1,3},{2,3},{2,4}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,5},{2,6},{4,7},{6,8}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{0,0},{0,0}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{0,2},{1,3},{3,4},{2,5}})",
          "expected": "2"
        },
        {
          "call": "MaxNonOverlapping([][]int{{1,2},{2,3},{3,4},{1,3}})",
          "expected": "3"
        }
      ]
    },
    {
      "title": "DP Bottom-Up: Coin Change (Min Coins)",
      "slug": "coin-change-min",
      "description": "Given coin denominations and an amount, return the minimum number of coins to make that amount, or -1 if impossible. Use bottom-up DP.",
      "visible_skeleton": "func CoinChangeMin(coins []int, amount int) int {\n\t// classic unbounded knapsack variant\n\treturn -1\n}\n",
      "test_cases": [
        {
          "call": "CoinChangeMin([]int{1,2,5}, 11)",
          "expected": "3"
        },
        {
          "call": "CoinChangeMin([]int{2}, 3)",
          "expected": "-1"
        },
        {
          "call": "CoinChangeMin([]int{1}, 0)",
          "expected": "0"
        },
        {
          "call": "CoinChangeMin([]int{1}, 2)",
          "expected": "2"
        },
        {
          "call": "CoinChangeMin([]int{2,5,10,1}, 27)",
          "expected": "4"
        },
        {
          "call": "CoinChangeMin([]int{186,419,83,408}, 6249)",
          "expected": "20"
        },
        {
          "call": "CoinChangeMin([]int{2}, 1)",
          "expected": "-1"
        },
        {
          "call": "CoinChangeMin([]int{1,3,4}, 6)",
          "expected": "2"
        },
        {
          "call": "CoinChangeMin([]int{1,3,4}, 5)",
          "expected": "2"
        },
        {
          "call": "CoinChangeMin([]int{1,3,4}, 7)",
          "expected": "2"
        },
        {
          "call": "CoinChangeMin([]int{2,4}, 8)",
          "expected": "2"
        },
        {
          "call": "CoinChangeMin([]int{2,4}, 7)",
          "expected": "-1"
        },
        {
          "call": "CoinChangeMin([]int{5,10,25}, 30)",
          "expected": "2"
        },
        {
          "call": "CoinChangeMin([]int{5,10,25}, 5)",
          "expected": "1"
        },
        {
          "call": "CoinChangeMin([]int{5,10,25}, 1)",
          "expected": "-1"
        },
        {
          "call": "CoinChangeMin([]int{1,7,10}, 14)",
          "expected": "2"
        },
        {
          "call": "CoinChangeMin([]int{3,7}, 21)",
          "expected": "3"
        },
        {
          "call": "CoinChangeMin([]int{3,7}, 22)",
          "expected": "-1"
        },
        {
          "call": "CoinChangeMin([]int{9,6,5,1}, 11)",
          "expected": "2"
        },
        {
          "call": "CoinChangeMin([]int{2,5,7}, 27)",
          "expected": "5"
        }
      ]
    },
    {
      "title": "Topological Sort: Course Schedule Possible",
      "slug": "course-schedule-possible",
      "description": "Given numCourses and prerequisite pairs [a,b] meaning b -> a, return true if it's possible to finish all courses (i.e., the graph is acyclic).",
      "visible_skeleton": "func CanFinish(numCourses int, prerequisites [][]int) bool {\n\t// topo sort via Kahn (BFS) or DFS cycle check\n\treturn false\n}\n",
      "test_cases": [
        {
          "call": "CanFinish(2, [][]int{{1,0}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(2, [][]int{{1,0},{0,1}})",
          "expected": "false"
        },
        {
          "call": "CanFinish(1, [][]int{})",
          "expected": "true"
        },
        {
          "call": "CanFinish(3, [][]int{{1,0},{2,1}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(3, [][]int{{1,0},{2,1},{0,2}})",
          "expected": "false"
        },
        {
          "call": "CanFinish(4, [][]int{{1,0},{2,0},{3,1},{3,2}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(4, [][]int{{1,0},{2,1},{1,2}})",
          "expected": "false"
        },
        {
          "call": "CanFinish(5, [][]int{{1,0},{2,0},{3,1},{3,2},{4,3}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(5, [][]int{{1,0},{0,1},{2,3}})",
          "expected": "false"
        },
        {
          "call": "CanFinish(3, [][]int{})",
          "expected": "true"
        },
        {
          "call": "CanFinish(3, [][]int{{0,1}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(3, [][]int{{0,1},{1,2}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(3, [][]int{{0,1},{1,2},{2,0}})",
          "expected": "false"
        },
        {
          "call": "CanFinish(2, [][]int{{0,1}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(2, [][]int{{0,1},{1,0}})",
          "expected": "false"
        },
        {
          "call": "CanFinish(6, [][]int{{1,0},{2,1},{3,2},{4,3},{5,4}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(6, [][]int{{1,0},{2,1},{3,2},{1,3}})",
          "expected": "false"
        },
        {
          "call": "CanFinish(4, [][]int{{2,0},{2,1},{3,2}})",
          "expected": "true"
        },
        {
          "call": "CanFinish(4, [][]int{{2,0},{2,1},{0,2}})",
          "expected": "false"
        },
        {
          "call": "CanFinish(0, [][]int{})",
          "expected": "true"
        }
      ]
    },
    {
      "title": "Hash Tables: First Unique Character Index",
      "slug": "first-unique-char-index",
      "description": "Given a lowercase string, return the index of the first non-repeating character, or -1 if none.",
      "visible_skeleton": "func FirstUniqueCharIndex(s string) int {\n\t// use frequency map\n\treturn -1\n}\n",
      "test_cases": [
        {
          "call": "FirstUniqueCharIndex(\"\")",
          "expected": "-1"
        },
        {
          "call": "FirstUniqueCharIndex(\"a\")",
          "expected": "0"
        },
        {
          "call": "FirstUniqueCharIndex(\"aa\")",
          "expected": "-1"
        },
        {
          "call": "FirstUniqueCharIndex(\"leetcode\")",
          "expected": "0"
        },
        {
          "call": "FirstUniqueCharIndex(\"loveleetcode\")",
          "expected": "2"
        },
        {
          "call": "FirstUniqueCharIndex(\"aabb\")",
          "expected": "-1"
        },
        {
          "call": "FirstUniqueCharIndex(\"abcabcde\")",
          "expected": "6"
        },
        {
          "call": "FirstUniqueCharIndex(\"abcdabc\")",
          "expected": "3"
        },
        {
          "call": "FirstUniqueCharIndex(\"z\")",
          "expected": "0"
        },
        {
          "call": "FirstUniqueCharIndex(\"zzzzzz\")",
          "expected": "-1"
        },
        {
          "call": "FirstUniqueCharIndex(\"abacabad\")",
          "expected": "6"
        },
        {
          "call": "FirstUniqueCharIndex(\"xxyyzzq\")",
          "expected": "6"
        },
        {
          "call": "FirstUniqueCharIndex(\"aabccdbe\")",
          "expected": "7"
        },
        {
          "call": "FirstUniqueCharIndex(\"abcabc\")",
          "expected": "-1"
        },
        {
          "call": "FirstUniqueCharIndex(\"swiss\")",
          "expected": "1"
        },
        {
          "call": "FirstUniqueCharIndex(\"character\")",
          "expected": "2"
        },
        {
          "call": "FirstUniqueCharIndex(\"redivider\")",
          "expected": "-1"
        },
        {
          "call": "FirstUniqueCharIndex(\"teeter\")",
          "expected": "2"
        },
        {
          "call": "FirstUniqueCharIndex(\"mississippi\")",
          "expected": "-1"
        },
        {
          "call": "FirstUniqueCharIndex(\"xyzxy\")",
          "expected": "2"
        }
      ]
    },
    {
      "title": "Linked List: Middle Node Value",
      "slug": "linked-list-middle-value",
      "description": "Given a slice, build a singly linked list and return the value of its middle node. For even length, return the second middle.",
      "visible_skeleton": "type ListNode struct { Val int; Next *ListNode }\n\nfunc MiddleNodeValue(nums []int) int {\n\t// build list, use slow/fast pointers\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "MiddleNodeValue([]int{1})",
          "expected": "1"
        },
        {
          "call": "MiddleNodeValue([]int{1,2})",
          "expected": "2"
        },
        {
          "call": "MiddleNodeValue([]int{1,2,3})",
          "expected": "2"
        },
        {
          "call": "MiddleNodeValue([]int{1,2,3,4})",
          "expected": "3"
        },
        {
          "call": "MiddleNodeValue([]int{1,2,3,4,5})",
          "expected": "3"
        },
        {
          "call": "MiddleNodeValue([]int{10,20,30,40,50,60})",
          "expected": "40"
        },
        {
          "call": "MiddleNodeValue([]int{7,7,7,7,7,7,7})",
          "expected": "7"
        },
        {
          "call": "MiddleNodeValue([]int{-1,-2,-3,-4})",
          "expected": "-2"
        },
        {
          "call": "MiddleNodeValue([]int{0,1})",
          "expected": "1"
        },
        {
          "call": "MiddleNodeValue([]int{0,1,2,3,4,5})",
          "expected": "3"
        },
        {
          "call": "MiddleNodeValue([]int{5,4,3,2,1})",
          "expected": "3"
        },
        {
          "call": "MiddleNodeValue([]int{9,8,7})",
          "expected": "8"
        },
        {
          "call": "MiddleNodeValue([]int{2,2,2,2})",
          "expected": "2"
        },
        {
          "call": "MiddleNodeValue([]int{1,3,5,7,9,11,13,15})",
          "expected": "9"
        },
        {
          "call": "MiddleNodeValue([]int{100,200,300})",
          "expected": "200"
        },
        {
          "call": "MiddleNodeValue([]int{-5})",
          "expected": "-5"
        },
        {
          "call": "MiddleNodeValue([]int{1,2,3,4,5,6,7,8,9,10})",
          "expected": "6"
        },
        {
          "call": "MiddleNodeValue([]int{42,43})",
          "expected": "43"
        },
        {
          "call": "MiddleNodeValue([]int{1,2,3,4,5,6,7,8})",
          "expected": "5"
        },
        {
          "call": "MiddleNodeValue([]int{3,1})",
          "expected": "1"
        }
      ]
    },
    {
      "title": "Stacks: Evaluate Reverse Polish Notation",
      "slug": "eval-rpn",
      "description": "Evaluate an RPN expression with +, -, *, /. Integer division should truncate toward zero.",
      "visible_skeleton": "func EvalRPN(tokens []string) int {\n\t// stack; remember integer division truncates toward zero\n\treturn 0\n}\n",
      "test_cases": [
        {
          "call": "EvalRPN([]string{\"2\",\"1\",\"+\",\"3\",\"*\"})",
          "expected": "9"
        },
        {
          "call": "EvalRPN([]string{\"4\",\"13\",\"5\",\"/\",\"+\"})",
          "expected": "6"
        },
        {
          "call": "EvalRPN([]string{\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"})",
          "expected": "22"
        },
        {
          "call": "EvalRPN([]string{\"3\",\"4\",\"+\"})",
          "expected": "7"
        },
        {
          "call": "EvalRPN([]string{\"3\",\"4\",\"-\"})",
          "expected": "-1"
        },
        {
          "call": "EvalRPN([]string{\"3\",\"-4\",\"-\"})",
          "expected": "7"
        },
        {
          "call": "EvalRPN([]string{\"3\",\"-4\",\"+\"})",
          "expected": "-1"
        },
        {
          "call": "EvalRPN([]string{\"5\",\"1\",\"2\",\"+\",\"4\",\"*\",\"+\",\"3\",\"-\"})",
          "expected": "14"
        },
        {
          "call": "EvalRPN([]string{\"7\",\"2\",\"/\"})",
          "expected": "3"
        },
        {
          "call": "EvalRPN([]string{\"7\",\"-2\",\"/\"})",
          "expected": "-3"
        },
        {
          "call": "EvalRPN([]string{\"-7\",\"2\",\"/\"})",
          "expected": "-3"
        },
        {
          "call": "EvalRPN([]string{\"-7\",\"-2\",\"/\"})",
          "expected": "3"
        },
        {
          "call": "EvalRPN([]string{\"2\",\"3\",\"4\",\"*\",\"+\"})",
          "expected": "14"
        },
        {
          "call": "EvalRPN([]string{\"2\",\"3\",\"+\",\"4\",\"*\"})",
          "expected": "20"
        },
        {
          "call": "EvalRPN([]string{\"12\",\"3\",\"/\",\"2\",\"*\"})",
          "expected": "8"
        },
        {
          "call": "EvalRPN([]string{\"0\",\"3\",\"/\"})",
          "expected": "0"
        },
        {
          "call": "EvalRPN([]string{\"3\",\"0\",\"+\"})",
          "expected": "3"
        },
        {
          "call": "EvalRPN([]string{\"5\",\"9\",\"1\",\"-\",\"/\"})",
          "expected": "0"
        },
        {
          "call": "EvalRPN([]string{\"1\",\"1\",\"1\",\"+\",\"+\"})",
          "expected": "3"
        },
        {
          "call": "EvalRPN([]string{\"100\",\"200\",\"+\",\"2\",\"/\",\"5\",\"*\",\"7\",\"+\"})",
          "expected": "757"
        }
      ]
    }
  ]
}
