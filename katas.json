{"katas":[{"title":"Two Sum II (Sorted, Two Pointers)","slug":"two-sum-ii-sorted","description":"Given a sorted slice of integers and a target, return true if any two numbers sum to the target.","visible_skeleton":"func TwoSumSorted(nums []int, target int) bool {\n\t// nums is sorted non-decreasing\n\treturn false\n}\n","test_cases":[{"call":"TwoSumSorted([]int{1,2,3,4}, 5)","expected":"true"},{"call":"TwoSumSorted([]int{1,2,3,4}, 7)","expected":"true"},{"call":"TwoSumSorted([]int{1,2,3,4}, 8)","expected":"false"},{"call":"TwoSumSorted([]int{}, 0)","expected":"false"},{"call":"TwoSumSorted([]int{5}, 5)","expected":"false"},{"call":"TwoSumSorted([]int{-3,-1,2,4}, 1)","expected":"true"},{"call":"TwoSumSorted([]int{-3,-1,2,4}, 10)","expected":"false"},{"call":"TwoSumSorted([]int{2,2}, 4)","expected":"true"},{"call":"TwoSumSorted([]int{2,3,5,9}, 7)","expected":"true"},{"call":"TwoSumSorted([]int{2,3,5,9}, 10)","expected":"false"}]},{"title":"Container With Most Water","slug":"container-most-water","description":"Given heights of vertical lines, return the maximum area of water a container can store.","visible_skeleton":"func MaxArea(height []int) int {\n\treturn 0\n}\n","test_cases":[{"call":"MaxArea([]int{1,8,6,2,5,4,8,3,7})","expected":"49"},{"call":"MaxArea([]int{1,1})","expected":"1"},{"call":"MaxArea([]int{4,3,2,1,4})","expected":"16"},{"call":"MaxArea([]int{1,2,1})","expected":"2"},{"call":"MaxArea([]int{2,3,10,5,7,8,9})","expected":"36"},{"call":"MaxArea([]int{1,2,3,4,5,25,24,3,4})","expected":"24"},{"call":"MaxArea([]int{2,2,2,2,2})","expected":"8"},{"call":"MaxArea([]int{5,4,3,2,1})","expected":"6"},{"call":"MaxArea([]int{10,9,8,7,6,5,4,3,2,1})","expected":"25"},{"call":"MaxArea([]int{1,3,2,5,25,24,5})","expected":"24"}]},{"title":"3Sum","slug":"three-sum","description":"Return all unique triplets [a,b,c] such that a+b+c=0 (triplets in non-decreasing order, list sorted lexicographically).","visible_skeleton":"func ThreeSum(nums []int) [][]int {\n\treturn nil\n}\n","test_cases":[{"call":"ThreeSum([]int{-1,0,1,2,-1,-4})","expected":"[[-1, -1, 2], [-1, 0, 1]]"},{"call":"ThreeSum([]int{})","expected":"[]"},{"call":"ThreeSum([]int{0,0,0})","expected":"[[0, 0, 0]]"},{"call":"ThreeSum([]int{3,-2,1,0})","expected":"[]"},{"call":"ThreeSum([]int{1,2,-2,-1})","expected":"[]"},{"call":"ThreeSum([]int{0,0,0,0})","expected":"[[0, 0, 0]]"},{"call":"ThreeSum([]int{-2,0,1,1,2})","expected":"[[-2, 0, 2], [-2, 1, 1]]"},{"call":"ThreeSum([]int{-1,0,1})","expected":"[[-1, 0, 1]]"},{"call":"ThreeSum([]int{1,1,-2})","expected":"[[-2, 1, 1]]"},{"call":"ThreeSum([]int{-4,-2,-2,0,1,2,3,4})","expected":"[[-4, 0, 4], [-4, 1, 3], [-2, -2, 4], [-2, 0, 2]]"}]},{"title":"Sort Colors (Dutch National Flag)","slug":"sort-colors","description":"Sort an array of 0s, 1s and 2s in-place.","visible_skeleton":"func SortColors(nums []int) []int {\n\treturn nums\n}\n","test_cases":[{"call":"SortColors([]int{2,0,2,1,1,0})","expected":"[0, 0, 1, 1, 2, 2]"},{"call":"SortColors([]int{2,0,1})","expected":"[0, 1, 2]"},{"call":"SortColors([]int{0})","expected":"[0]"},{"call":"SortColors([]int{1})","expected":"[1]"},{"call":"SortColors([]int{2})","expected":"[2]"},{"call":"SortColors([]int{1,2,0})","expected":"[0, 1, 2]"},{"call":"SortColors([]int{0,1,2,0,1,2})","expected":"[0, 0, 1, 1, 2, 2]"},{"call":"SortColors([]int{2,2,2})","expected":"[2, 2, 2]"},{"call":"SortColors([]int{0,0,1,1,2,2})","expected":"[0, 0, 1, 1, 2, 2]"},{"call":"SortColors([]int{1,0,1,2,0,2,1})","expected":"[0, 0, 1, 1, 1, 2, 2]"}]},{"title":"Linked List Cycle Detection (Floyd's Tortoise & Hare)","slug":"linked-list-cycle","description":"Given values and a pos index where the tail connects to form a cycle (-1 for no cycle), return true if the list has a cycle.","visible_skeleton":"func HasCycle(vals []int, pos int) bool {\n\treturn false\n}\n","test_cases":[{"call":"HasCycle([]int{3,2,0,-4}, 1)","expected":"true"},{"call":"HasCycle([]int{1,2}, 0)","expected":"true"},{"call":"HasCycle([]int{1}, -1)","expected":"false"},{"call":"HasCycle([]int{}, -1)","expected":"false"},{"call":"HasCycle([]int{1,2,3,4,5}, 2)","expected":"true"},{"call":"HasCycle([]int{1,2,3,4,5}, -1)","expected":"false"},{"call":"HasCycle([]int{1,1,1,1}, 0)","expected":"true"},{"call":"HasCycle([]int{1,2}, -1)","expected":"false"},{"call":"HasCycle([]int{0,1,2,3,4,5,6,7}, 3)","expected":"true"},{"call":"HasCycle([]int{10,20,30}, -1)","expected":"false"}]},{"title":"Longest Substring Without Repeating Characters","slug":"longest-substring-unique","description":"Return the length of the longest substring without repeating characters.","visible_skeleton":"func LengthOfLongestSubstring(s string) int {\n\treturn 0\n}\n","test_cases":[{"call":"LengthOfLongestSubstring(\"abcabcbb\")","expected":"3"},{"call":"LengthOfLongestSubstring(\"bbbbb\")","expected":"1"},{"call":"LengthOfLongestSubstring(\"pwwkew\")","expected":"3"},{"call":"LengthOfLongestSubstring(\"\")","expected":"0"},{"call":"LengthOfLongestSubstring(\"a\")","expected":"1"},{"call":"LengthOfLongestSubstring(\"au\")","expected":"2"},{"call":"LengthOfLongestSubstring(\"dvdf\")","expected":"3"},{"call":"LengthOfLongestSubstring(\"abba\")","expected":"2"},{"call":"LengthOfLongestSubstring(\"tmmzuxt\")","expected":"5"},{"call":"LengthOfLongestSubstring(\"anviaj\")","expected":"5"}]},{"title":"Minimum Window Substring","slug":"minimum-window-substring","description":"Given strings s and t, return the minimum window in s which will contain all the characters in t. If no such window exists, return empty string.","visible_skeleton":"func MinWindow(s string, t string) string {\n\treturn \"\"\n}\n","test_cases":[{"call":"MinWindow(\"ADOBECODEBANC\", \"ABC\")","expected":"\"BANC\""},{"call":"MinWindow(\"a\", \"a\")","expected":"\"a\""},{"call":"MinWindow(\"a\", \"aa\")","expected":"\"\""},{"call":"MinWindow(\"ab\", \"b\")","expected":"\"b\""},{"call":"MinWindow(\"ab\", \"a\")","expected":"\"a\""},{"call":"MinWindow(\"ab\", \"ab\")","expected":"\"ab\""},{"call":"MinWindow(\"bbaa\", \"aba\")","expected":"\"baa\""},{"call":"MinWindow(\"aa\", \"aa\")","expected":"\"aa\""},{"call":"MinWindow(\"aa\", \"aaa\")","expected":"\"\""},{"call":"MinWindow(\"cabwefgewcwaefgcf\", \"cae\")","expected":"\"cwae\""}]},{"title":"Merge Intervals","slug":"merge-intervals","description":"Given a list of intervals, merge all overlapping intervals.","visible_skeleton":"func MergeIntervals(intervals [][]int) [][]int {\n\treturn nil\n}\n","test_cases":[{"call":"MergeIntervals([][]int{[]int{1, 3}, []int{2, 6}, []int{8, 10}, []int{15, 18}})","expected":"[[1, 6], [8, 10], [15, 18]]"},{"call":"MergeIntervals([][]int{[]int{1, 4}, []int{4, 5}})","expected":"[[1, 5]]"},{"call":"MergeIntervals([][]int{[]int{1, 4}, []int{2, 3}})","expected":"[[1, 4]]"},{"call":"MergeIntervals([][]int{[]int{1, 4}, []int{0, 4}})","expected":"[[0, 4]]"},{"call":"MergeIntervals([][]int{[]int{1, 4}, []int{0, 2}, []int{3, 5}})","expected":"[[0, 5]]"},{"call":"MergeIntervals([][]int{[]int{1, 5}})","expected":"[[1, 5]]"},{"call":"MergeIntervals([][]int{[]int{1, 4}, []int{2, 6}, []int{6, 8}})","expected":"[[1, 8]]"},{"call":"MergeIntervals([][]int{[]int{1, 4}, []int{0, 2}, []int{3, 4}})","expected":"[[0, 4]]"},{"call":"MergeIntervals([][]int{[]int{1, 3}, []int{2, 4}, []int{5, 7}, []int{6, 8}})","expected":"[[1, 4], [5, 8]]"},{"call":"MergeIntervals([][]int{[]int{1, 10}, []int{2, 3}, []int{4, 5}, []int{6, 7}, []int{8, 9}})","expected":"[[1, 10]]"}]},{"title":"Insert Interval","slug":"insert-interval","description":"Insert a new interval into a list of non-overlapping intervals and merge if necessary.","visible_skeleton":"func InsertInterval(intervals [][]int, newInterval []int) [][]int {\n\treturn nil\n}\n","test_cases":[{"call":"InsertInterval([][]int{[]int{1, 3}, []int{6, 9}}, []int{2, 5})","expected":"[[1, 5], [6, 9]]"},{"call":"InsertInterval([][]int{[]int{1, 2}, []int{3, 5}, []int{6, 7}, []int{8, 10}, []int{12, 16}}, []int{4, 8})","expected":"[[1, 2], [3, 10], [12, 16]]"},{"call":"InsertInterval([][]int{}, []int{5, 7})","expected":"[[5, 7]]"},{"call":"InsertInterval([][]int{[]int{1, 5}}, []int{2, 3})","expected":"[[1, 5]]"},{"call":"InsertInterval([][]int{[]int{1, 5}}, []int{2, 7})","expected":"[[1, 7]]"},{"call":"InsertInterval([][]int{[]int{1, 5}}, []int{6, 8})","expected":"[[1, 5], [6, 8]]"},{"call":"InsertInterval([][]int{[]int{1, 3}, []int{4, 6}}, []int{2, 5})","expected":"[[1, 6]]"},{"call":"InsertInterval([][]int{[]int{1, 3}, []int{5, 7}}, []int{8, 10})","expected":"[[1, 3], [5, 7], [8, 10]]"},{"call":"InsertInterval([][]int{[]int{3, 5}, []int{12, 15}}, []int{6, 6})","expected":"[[3, 5], [6, 6], [12, 15]]"},{"call":"InsertInterval([][]int{[]int{1, 4}, []int{5, 6}}, []int{2, 3})","expected":"[[1, 4], [5, 6]]"}]},{"title":"Valid Parentheses","slug":"valid-parentheses","description":"Given a string of parentheses, return true if it is valid.","visible_skeleton":"func IsValidParentheses(s string) bool {\n\treturn false\n}\n","test_cases":[{"call":"IsValidParentheses(\"()\")","expected":"true"},{"call":"IsValidParentheses(\"()[]{}\")","expected":"true"},{"call":"IsValidParentheses(\"(]\")","expected":"false"},{"call":"IsValidParentheses(\"([)]\")","expected":"false"},{"call":"IsValidParentheses(\"{[]}\")","expected":"true"},{"call":"IsValidParentheses(\"\")","expected":"true"},{"call":"IsValidParentheses(\"(((((\")","expected":"false"},{"call":"IsValidParentheses(\"}}}}\")","expected":"false"},{"call":"IsValidParentheses(\"([])\")","expected":"true"},{"call":"IsValidParentheses(\"(([]){})\")","expected":"true"}]},{"title":"Min Stack (operation simulation)","slug":"min-stack-sim","description":"Simulate a MinStack. Given ops (push/pop/top/getMin) and values for pushes, return outputs as strings for each op (use \"null\" for non-returning ops).","visible_skeleton":"func MinStackSim(ops []string, vals []int) []string {\n\t// ops contains push/pop/top/getMin; vals provides values for push operations in order\n\treturn nil\n}\n","test_cases":[{"call":"MinStackSim([]string{\"push\", \"push\", \"push\", \"getMin\", \"pop\", \"top\", \"getMin\"}, []int{2,0,3})","expected":"[\"null\", \"null\", \"null\", \"0\", \"null\", \"0\", \"0\"]"},{"call":"MinStackSim([]string{\"push\", \"push\", \"getMin\", \"push\", \"getMin\", \"pop\", \"getMin\"}, []int{5,3,1})","expected":"[\"null\", \"null\", \"3\", \"null\", \"1\", \"null\", \"3\"]"},{"call":"MinStackSim([]string{\"push\", \"top\", \"pop\", \"getMin\"}, []int{7})","expected":"[\"null\", \"7\", \"null\", \"null\"]"},{"call":"MinStackSim([]string{\"push\", \"push\", \"pop\", \"getMin\"}, []int{10,-1})","expected":"[\"null\", \"null\", \"null\", \"10\"]"},{"call":"MinStackSim([]string{\"getMin\"}, []int{})","expected":"[\"null\"]"},{"call":"MinStackSim([]string{\"push\", \"push\", \"push\", \"pop\", \"pop\", \"getMin\"}, []int{3,4,5})","expected":"[\"null\", \"null\", \"null\", \"null\", \"null\", \"3\"]"},{"call":"MinStackSim([]string{\"push\", \"getMin\", \"push\", \"getMin\", \"push\", \"getMin\"}, []int{2,1,3})","expected":"[\"null\", \"2\", \"null\", \"1\", \"null\", \"1\"]"},{"call":"MinStackSim([]string{\"push\", \"push\", \"top\", \"getMin\", \"pop\", \"top\", \"getMin\"}, []int{0,0})","expected":"[\"null\", \"null\", \"0\", \"0\", \"null\", \"0\", \"0\"]"},{"call":"MinStackSim([]string{\"push\", \"push\", \"push\", \"push\", \"getMin\", \"pop\", \"getMin\"}, []int{9,8,7,6})","expected":"[\"null\", \"null\", \"null\", \"null\", \"6\", \"null\", \"7\"]"},{"call":"MinStackSim([]string{\"push\", \"pop\", \"pop\", \"getMin\"}, []int{1})","expected":"[\"null\", \"null\", \"null\", \"null\"]"}]},{"title":"Next Greater Element I","slug":"next-greater-element-i","description":"For each element in nums1, find the next greater element in nums2; return -1 if none.","visible_skeleton":"func NextGreaterElement(nums1 []int, nums2 []int) []int {\n\treturn nil\n}\n","test_cases":[{"call":"NextGreaterElement([]int{4,1,2}, []int{1,3,4,2})","expected":"[-1, 3, -1]"},{"call":"NextGreaterElement([]int{2,4}, []int{1,2,3,4})","expected":"[3, -1]"},{"call":"NextGreaterElement([]int{1,3,5,2,4}, []int{6,5,4,3,2,1,7})","expected":"[7, 7, 7, 7, 7]"},{"call":"NextGreaterElement([]int{2,1,3}, []int{2,3,1})","expected":"[3, -1, -1]"},{"call":"NextGreaterElement([]int{1}, []int{1})","expected":"[-1]"},{"call":"NextGreaterElement([]int{1,2}, []int{2,1})","expected":"[-1, -1]"},{"call":"NextGreaterElement([]int{1,2,3}, []int{3,2,1})","expected":"[-1, -1, -1]"},{"call":"NextGreaterElement([]int{4,2}, []int{1,2,3,4,5})","expected":"[5, 3]"},{"call":"NextGreaterElement([]int{2,3}, []int{2,3,1})","expected":"[3, -1]"},{"call":"NextGreaterElement([]int{1,5,3}, []int{6,5,4,3,2,1})","expected":"[-1, -1, -1]"}]},{"title":"Largest Rectangle in Histogram","slug":"largest-rectangle-histogram","description":"Given heights of histogram bars, return the area of the largest rectangle in the histogram.","visible_skeleton":"func LargestRectangleArea(heights []int) int {\n\treturn 0\n}\n","test_cases":[{"call":"LargestRectangleArea([]int{2,1,5,6,2,3})","expected":"10"},{"call":"LargestRectangleArea([]int{2,4})","expected":"4"},{"call":"LargestRectangleArea([]int{1,1})","expected":"2"},{"call":"LargestRectangleArea([]int{1})","expected":"1"},{"call":"LargestRectangleArea([]int{6,2,5,4,5,1,6})","expected":"12"},{"call":"LargestRectangleArea([]int{0})","expected":"0"},{"call":"LargestRectangleArea([]int{4,2,0,3,2,5})","expected":"6"},{"call":"LargestRectangleArea([]int{2,1,2})","expected":"3"},{"call":"LargestRectangleArea([]int{3,6,5,7,4,8,1,0})","expected":"20"},{"call":"LargestRectangleArea([]int{1,2,3,4,5})","expected":"9"}]},{"title":"Group Anagrams","slug":"group-anagrams","description":"Group words that are anagrams; within each group and across groups, order does not matter.","visible_skeleton":"func GroupAnagrams(words []string) [][]string {\n\treturn nil\n}\n","test_cases":[{"call":"GroupAnagrams([]string{\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"})","expected":"[[\"ate\", \"eat\", \"tea\"], [\"bat\"], [\"nat\", \"tan\"]]"},{"call":"GroupAnagrams([]string{\"\"})","expected":"[[\"\"]]"},{"call":"GroupAnagrams([]string{\"a\"})","expected":"[[\"a\"]]"},{"call":"GroupAnagrams([]string{\"ab\", \"ba\", \"abc\", \"cba\", \"bca\", \"cab\"})","expected":"[[\"ab\", \"ba\"], [\"abc\", \"bca\", \"cab\", \"cba\"]]"},{"call":"GroupAnagrams([]string{\"listen\", \"silent\", \"enlist\", \"google\", \"gooegl\"})","expected":"[[\"enlist\", \"listen\", \"silent\"], [\"gooegl\", \"google\"]]"},{"call":"GroupAnagrams([]string{\"zzz\", \"zzz\", \"zz\"})","expected":"[[\"zz\"], [\"zzz\", \"zzz\"]]"},{"call":"GroupAnagrams([]string{\"bob\", \"obb\", \"bbo\", \"obo\"})","expected":"[[\"bbo\", \"bob\", \"obb\"], [\"obo\"]]"},{"call":"GroupAnagrams([]string{\"x\", \"y\", \"z\"})","expected":"[[\"x\"], [\"y\"], [\"z\"]]"},{"call":"GroupAnagrams([]string{\"\", \"\"})","expected":"[[\"\", \"\"]]"},{"call":"GroupAnagrams([]string{\"rat\", \"tar\", \"art\", \"car\"})","expected":"[[\"art\", \"rat\", \"tar\"], [\"car\"]]"}]},{"title":"Binary Tree Level Order Traversal (array input)","slug":"bt-level-order-levels","description":"Input is level-order array with -1 as null. Return levels as [][]int (omit nulls).","visible_skeleton":"func LevelOrderLevels(arr []int) [][]int {\n\t// -1 denotes null\n\treturn nil\n}\n","test_cases":[{"call":"LevelOrderLevels([]int{3,9,20,-1,-1,15,7})","expected":"[[3], [9, 20], [15, 7]]"},{"call":"LevelOrderLevels([]int{})","expected":"[]"},{"call":"LevelOrderLevels([]int{1})","expected":"[[1]]"},{"call":"LevelOrderLevels([]int{1,2,3,4,5,-1,6})","expected":"[[1], [2, 3], [4, 5, 6]]"},{"call":"LevelOrderLevels([]int{5,4,8,11,-1,13,4,7,2,-1,-1,-1,1})","expected":"[[5], [4, 8], [11, 13, 4], [7, 2, 1]]"},{"call":"LevelOrderLevels([]int{1,-1,2,-1,3})","expected":"[[1], [2]]"},{"call":"LevelOrderLevels([]int{1,2})","expected":"[[1], [2]]"},{"call":"LevelOrderLevels([]int{1,-1,2,3})","expected":"[[1], [2]]"},{"call":"LevelOrderLevels([]int{0,-1,-1})","expected":"[[0]]"},{"call":"LevelOrderLevels([]int{2,1,3})","expected":"[[2], [1, 3]]"}]},{"title":"Path Sum (root-to-leaf equals target)","slug":"bt-path-sum-exists","description":"Return true if there exists a root-to-leaf path with sum == target. Tree given as level-order array with -1 as null.","visible_skeleton":"func HasPathSumArray(arr []int, target int) bool {\n\treturn false\n}\n","test_cases":[{"call":"HasPathSumArray([]int{5,4,8,11,-1,13,4,7,2,-1,-1,-1,1}, 22)","expected":"true"},{"call":"HasPathSumArray([]int{1,2,3}, 5)","expected":"false"},{"call":"HasPathSumArray([]int{1,2}, 1)","expected":"false"},{"call":"HasPathSumArray([]int{1,2}, 3)","expected":"true"},{"call":"HasPathSumArray([]int{}, 0)","expected":"false"},{"call":"HasPathSumArray([]int{1,-1,2,-1,3}, 6)","expected":"false"},{"call":"HasPathSumArray([]int{1,-1,2,-1,3}, 3)","expected":"true"},{"call":"HasPathSumArray([]int{0}, 0)","expected":"true"},{"call":"HasPathSumArray([]int{2,1,3}, 4)","expected":"false"},{"call":"HasPathSumArray([]int{2,1,3}, 5)","expected":"true"}]},{"title":"Connected Components in an Undirected Graph","slug":"graph-connected-components","description":"Given n nodes labeled 0..n-1 and edges, return the number of connected components.","visible_skeleton":"func CountComponents(n int, edges [][]int) int {\n\treturn 0\n}\n","test_cases":[{"call":"CountComponents(5, [][]int{[]int{0, 1}, []int{1, 2}, []int{3, 4}})","expected":"2"},{"call":"CountComponents(5, [][]int{[]int{0, 1}, []int{1, 2}, []int{2, 3}, []int{3, 4}})","expected":"1"},{"call":"CountComponents(4, [][]int{})","expected":"4"},{"call":"CountComponents(1, [][]int{})","expected":"1"},{"call":"CountComponents(4, [][]int{[]int{0, 1}, []int{2, 3}})","expected":"2"},{"call":"CountComponents(6, [][]int{[]int{0, 1}, []int{1, 2}, []int{3, 4}})","expected":"3"},{"call":"CountComponents(3, [][]int{[]int{0, 1}, []int{1, 2}, []int{2, 0}})","expected":"1"},{"call":"CountComponents(7, [][]int{[]int{0, 1}, []int{2, 3}, []int{4, 5}})","expected":"4"},{"call":"CountComponents(2, [][]int{[]int{0, 1}})","expected":"1"},{"call":"CountComponents(10, [][]int{[]int{0, 1}, []int{2, 3}, []int{3, 4}, []int{5, 6}, []int{7, 8}, []int{8, 9}})","expected":"4"}]},{"title":"Number of Islands","slug":"number-of-islands","description":"Grid given as []string of '0' and '1'. Return number of islands (4-directional).","visible_skeleton":"func NumIslands(grid []string) int {\n\treturn 0\n}\n","test_cases":[{"call":"NumIslands([]string{\"11110\", \"11010\", \"11000\", \"00000\"})","expected":"1"},{"call":"NumIslands([]string{\"11000\", \"11000\", \"00100\", \"00011\"})","expected":"3"},{"call":"NumIslands([]string{\"0\"})","expected":"0"},{"call":"NumIslands([]string{\"1\"})","expected":"1"},{"call":"NumIslands([]string{\"10\", \"01\"})","expected":"2"},{"call":"NumIslands([]string{\"101\", \"010\", \"101\"})","expected":"5"},{"call":"NumIslands([]string{\"111\", \"010\", \"111\"})","expected":"1"},{"call":"NumIslands([]string{\"000\", \"000\", \"000\"})","expected":"0"},{"call":"NumIslands([]string{\"100\", \"000\", \"001\"})","expected":"2"},{"call":"NumIslands([]string{\"11011\", \"10001\", \"00100\", \"10001\", \"11011\"})","expected":"5"}]},{"title":"Online Medians (Two Heaps)","slug":"online-medians","description":"Return median after each insertion; output []float64 matching stream positions.","visible_skeleton":"func OnlineMedians(nums []int) []float64 {\n\treturn nil\n}\n","test_cases":[{"call":"OnlineMedians([]int{1,2,3,4,5})","expected":"[1.0, 1.5, 2.0, 2.5, 3.0]"},{"call":"OnlineMedians([]int{5,4,3,2,1})","expected":"[5.0, 4.5, 4.0, 3.5, 3.0]"},{"call":"OnlineMedians([]int{2,1,5,7,2,0,5})","expected":"[2.0, 1.5, 2.0, 3.5, 2.0, 2.0, 2.0]"},{"call":"OnlineMedians([]int{1})","expected":"[1.0]"},{"call":"OnlineMedians([]int{1,1,1,1})","expected":"[1.0, 1.0, 1.0, 1.0]"},{"call":"OnlineMedians([]int{10,20,30})","expected":"[10.0, 15.0, 20.0]"},{"call":"OnlineMedians([]int{3,8,9,2})","expected":"[3.0, 5.5, 8.0, 5.5]"},{"call":"OnlineMedians([]int{100,-1,50,-2,0})","expected":"[100.0, 49.5, 50.0, 24.5, 0.0]"},{"call":"OnlineMedians([]int{1,2})","expected":"[1.0, 1.5]"},{"call":"OnlineMedians([]int{0,0,0,1})","expected":"[0.0, 0.0, 0.0, 0.0]"}]},{"title":"Sliding Window Median (Two Heaps)","slug":"sliding-window-median","description":"Given nums and k, return median for each window as []float64.","visible_skeleton":"func SlidingWindowMedian(nums []int, k int) []float64 {\n\treturn nil\n}\n","test_cases":[{"call":"SlidingWindowMedian([]int{1,3,-1,-3,5,3,6,7}, 3)","expected":"[1.0, -1.0, -1.0, 3.0, 3.0, 3.0]"},{"call":"SlidingWindowMedian([]int{1,2}, 1)","expected":"[1.0, 2.0]"},{"call":"SlidingWindowMedian([]int{1,4,2,3}, 4)","expected":"[2.5]"},{"call":"SlidingWindowMedian([]int{0,0,0,0}, 2)","expected":"[0.0, 0.0, 0.0]"},{"call":"SlidingWindowMedian([]int{5,2,2,7,3,7,9,0,2,3}, 9)","expected":"[3.0, 3.0]"},{"call":"SlidingWindowMedian([]int{1}, 1)","expected":"[1.0]"},{"call":"SlidingWindowMedian([]int{2,2,2,2}, 2)","expected":"[2.0, 2.0, 2.0]"},{"call":"SlidingWindowMedian([]int{1,2,3,4,2,3,1}, 3)","expected":"[2.0, 2.0, 3.0, 3.0, 2.0]"},{"call":"SlidingWindowMedian([]int{7,0,3,9,9,9,1,7,2,3}, 6)","expected":"[8.0, 6.0, 8.0, 4.5, 5.0]"},{"call":"SlidingWindowMedian([]int{4,2,3,1}, 2)","expected":"[3.0, 2.5, 2.0]"}]},{"title":"Top K Frequent Elements","slug":"top-k-frequent","description":"Return the k most frequent elements (order of output sorted ascending for determinism).","visible_skeleton":"func TopKFrequent(nums []int, k int) []int {\n\treturn nil\n}\n","test_cases":[{"call":"TopKFrequent([]int{1,1,1,2,2,3}, 2)","expected":"[1, 2]"},{"call":"TopKFrequent([]int{1}, 1)","expected":"[1]"},{"call":"TopKFrequent([]int{4,1,-1,2,-1,2,3}, 2)","expected":"[-1, 2]"},{"call":"TopKFrequent([]int{1,2,3,4,5,6}, 3)","expected":"[1, 2, 3]"},{"call":"TopKFrequent([]int{1,1,2,2,3,3}, 1)","expected":"[1]"},{"call":"TopKFrequent([]int{0,0,0,0}, 1)","expected":"[0]"},{"call":"TopKFrequent([]int{5,5,5,6,6,7}, 2)","expected":"[5, 6]"},{"call":"TopKFrequent([]int{2,2,2,2,2}, 1)","expected":"[2]"},{"call":"TopKFrequent([]int{1,2,2,3,3,3}, 2)","expected":"[2, 3]"},{"call":"TopKFrequent([]int{9,8,7,6,5,4,3,2,1}, 4)","expected":"[1, 2, 3, 4]"}]},{"title":"Subsets (Power Set)","slug":"subsets","description":"Return all subsets of nums, with elements in non-decreasing order and subsets sorted lexicographically.","visible_skeleton":"func Subsets(nums []int) [][]int {\n\treturn nil\n}\n","test_cases":[{"call":"Subsets([]int{1,2,3})","expected":"[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]"},{"call":"Subsets([]int{0})","expected":"[[], [0]]"},{"call":"Subsets([]int{1,1,2})","expected":"[[], [1], [1], [1, 1], [2], [1, 2], [1, 2], [1, 1, 2]]"},{"call":"Subsets([]int{2,2})","expected":"[[], [2], [2], [2, 2]]"},{"call":"Subsets([]int{1,2,2,3})","expected":"[[], [1], [2], [1, 2], [2], [1, 2], [2, 2], [1, 2, 2], [3], [1, 3], [2, 3], [1, 2, 3], [2, 3], [1, 2, 3], [2, 2, 3], [1, 2, 2, 3]]"},{"call":"Subsets([]int{})","expected":"[[]]"},{"call":"Subsets([]int{5})","expected":"[[], [5]]"},{"call":"Subsets([]int{1,3,5})","expected":"[[], [1], [3], [1, 3], [5], [1, 5], [3, 5], [1, 3, 5]]"},{"call":"Subsets([]int{9,8})","expected":"[[], [8], [9], [8, 9]]"},{"call":"Subsets([]int{1,2,3,4})","expected":"[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3], [4], [1, 4], [2, 4], [1, 2, 4], [3, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]]"}]},{"title":"Combination Sum","slug":"combination-sum","description":"Return unique combinations where candidates sum to target. Reuse allowed. Subsets sorted lexicographically.","visible_skeleton":"func CombinationSum(candidates []int, target int) [][]int {\n\treturn nil\n}\n","test_cases":[{"call":"CombinationSum([]int{2,3,6,7}, 7)","expected":"[[2, 2, 3], [7]]"},{"call":"CombinationSum([]int{2,3,5}, 8)","expected":"[[2, 2, 2, 2], [2, 3, 3], [3, 5]]"},{"call":"CombinationSum([]int{2}, 1)","expected":"[]"},{"call":"CombinationSum([]int{1}, 1)","expected":"[[1]]"},{"call":"CombinationSum([]int{2}, 2)","expected":"[[2]]"},{"call":"CombinationSum([]int{3,4,5}, 9)","expected":"[[3, 3, 3], [4, 5]]"},{"call":"CombinationSum([]int{2,7,6,3,5,1}, 9)","expected":"[[1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 2], [1, 1, 1, 1, 1, 1, 3], [1, 1, 1, 1, 1, 2, 2], [1, 1, 1, 1, 2, 3], [1, 1, 1, 1, 5], [1, 1, 1, 2, 2, 2], [1, 1, 1, 3, 3], [1, 1, 1, 6], [1, 1, 2, 2, 3], [1, 1, 2, 5], [1, 1, 7], [1, 2, 2, 2, 2], [1, 2, 3, 3], [1, 2, 6], [1, 3, 5], [2, 2, 2, 3], [2, 2, 5], [2, 7], [3, 3, 3], [3, 6]]"},{"call":"CombinationSum([]int{8,7,4,3}, 11)","expected":"[[3, 4, 4], [3, 8], [4, 7]]"},{"call":"CombinationSum([]int{9,3,4,7}, 7)","expected":"[[3, 4], [7]]"},{"call":"CombinationSum([]int{10,1,2,7,6,1,5}, 8)","expected":"[[1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 2], [1, 1, 1, 1, 2, 2], [1, 1, 1, 5], [1, 1, 2, 2, 2], [1, 1, 6], [1, 2, 5], [1, 7], [2, 2, 2, 2], [2, 6]]"}]},{"title":"Word Search (exist)","slug":"word-search-exist","description":"Return true if the word exists in the board moving 4-directions without reusing a cell.","visible_skeleton":"func WordSearchExist(board []string, word string) bool {\n\treturn false\n}\n","test_cases":[{"call":"WordSearchExist([]string{\"ABCE\", \"SFCS\", \"ADEE\"}, \"ABCCED\")","expected":"true"},{"call":"WordSearchExist([]string{\"ABCE\", \"SFCS\", \"ADEE\"}, \"SEE\")","expected":"true"},{"call":"WordSearchExist([]string{\"ABCE\", \"SFCS\", \"ADEE\"}, \"ABCB\")","expected":"false"},{"call":"WordSearchExist([]string{\"A\"}, \"A\")","expected":"true"},{"call":"WordSearchExist([]string{\"A\"}, \"B\")","expected":"false"},{"call":"WordSearchExist([]string{\"CAADE\", \"COLAB\", \"TAXYZ\"}, \"CODE\")","expected":"false"},{"call":"WordSearchExist([]string{\"AAAA\", \"AAAA\", \"AAAA\"}, \"AAAAA\")","expected":"true"},{"call":"WordSearchExist([]string{\"CAT\", \"DOG\", \"PIG\"}, \"COD\")","expected":"false"},{"call":"WordSearchExist([]string{\"XY\", \"YZ\"}, \"XYZ\")","expected":"true"},{"call":"WordSearchExist([]string{\"ABC\", \"DEF\", \"GHI\"}, \"AEI\")","expected":"false"}]},{"title":"Search in Rotated Sorted Array","slug":"search-rotated","description":"Return index of target or -1 if not found.","visible_skeleton":"func SearchRotated(nums []int, target int) int {\n\treturn -1\n}\n","test_cases":[{"call":"SearchRotated([]int{4,5,6,7,0,1,2}, 0)","expected":"4"},{"call":"SearchRotated([]int{4,5,6,7,0,1,2}, 3)","expected":"-1"},{"call":"SearchRotated([]int{1}, 0)","expected":"-1"},{"call":"SearchRotated([]int{1}, 1)","expected":"0"},{"call":"SearchRotated([]int{1,3}, 3)","expected":"1"},{"call":"SearchRotated([]int{5,1,3}, 5)","expected":"0"},{"call":"SearchRotated([]int{5,1,3}, 1)","expected":"1"},{"call":"SearchRotated([]int{6,7,1,2,3,4,5}, 4)","expected":"5"},{"call":"SearchRotated([]int{}, 3)","expected":"-1"},{"call":"SearchRotated([]int{1,2,3,4,5}, 4)","expected":"3"}]},{"title":"Find Peak Element","slug":"find-peak-element","description":"Return any peak index.","visible_skeleton":"func FindPeakElement(nums []int) int {\n\treturn 0\n}\n","test_cases":[{"call":"FindPeakElement([]int{1,2,3,1})","expected":"2"},{"call":"FindPeakElement([]int{1,2,1,3,5,6,4})","expected":"5"},{"call":"FindPeakElement([]int{1})","expected":"0"},{"call":"FindPeakElement([]int{2,1})","expected":"0"},{"call":"FindPeakElement([]int{1,2})","expected":"1"},{"call":"FindPeakElement([]int{1,1,1})","expected":"0"},{"call":"FindPeakElement([]int{1,3,2,1})","expected":"1"},{"call":"FindPeakElement([]int{1,2,3,4,5})","expected":"4"},{"call":"FindPeakElement([]int{5,4,3,2,1})","expected":"0"},{"call":"FindPeakElement([]int{1,2,1,2,1})","expected":"3"}]},{"title":"Interval Scheduling (Max Non-Overlapping)","slug":"interval-scheduling","description":"Return maximum number of non-overlapping intervals.","visible_skeleton":"func MaxNonOverlappingIntervals(intervals [][]int) int {\n\treturn 0\n}\n","test_cases":[{"call":"MaxNonOverlappingIntervals([][]int{[]int{1, 2}, []int{2, 3}, []int{3, 4}, []int{1, 3}})","expected":"3"},{"call":"MaxNonOverlappingIntervals([][]int{[]int{1, 2}, []int{2, 3}})","expected":"2"},{"call":"MaxNonOverlappingIntervals([][]int{[]int{1, 2}, []int{1, 2}, []int{1, 2}})","expected":"1"},{"call":"MaxNonOverlappingIntervals([][]int{[]int{1, 2}, []int{2, 3}, []int{3, 4}})","expected":"3"},{"call":"MaxNonOverlappingIntervals([][]int{[]int{1, 3}, []int{2, 4}, []int{3, 5}, []int{7, 8}})","expected":"3"},{"call":"MaxNonOverlappingIntervals([][]int{[]int{1, 10}})","expected":"1"},{"call":"MaxNonOverlappingIntervals([][]int{})","expected":"0"},{"call":"MaxNonOverlappingIntervals([][]int{[]int{0, 0}, []int{0, 1}, []int{1, 1}})","expected":"3"},{"call":"MaxNonOverlappingIntervals([][]int{[]int{1, 2}, []int{2, 2}, []int{2, 3}, []int{3, 3}})","expected":"4"},{"call":"MaxNonOverlappingIntervals([][]int{[]int{-1, 1}, []int{0, 2}, []int{1, 3}})","expected":"2"}]},{"title":"Jump Game II (Min Jumps)","slug":"jump-game-ii","description":"Given nums where each element is max jump length, return minimal number of jumps to reach last index.","visible_skeleton":"func JumpGameII(nums []int) int {\n\treturn 0\n}\n","test_cases":[{"call":"JumpGameII([]int{2,3,1,1,4})","expected":"2"},{"call":"JumpGameII([]int{2,3,0,1,4})","expected":"2"},{"call":"JumpGameII([]int{1,2,3})","expected":"2"},{"call":"JumpGameII([]int{1})","expected":"0"},{"call":"JumpGameII([]int{0})","expected":"0"},{"call":"JumpGameII([]int{1,1,1,1})","expected":"3"},{"call":"JumpGameII([]int{3,2,1})","expected":"1"},{"call":"JumpGameII([]int{2,1})","expected":"1"},{"call":"JumpGameII([]int{1,0,1,0})","expected":"2"},{"call":"JumpGameII([]int{5,9,3,2,1,0,2,3,3,1,0,0})","expected":"3"}]},{"title":"Trie (Insert/Search/StartsWith Simulation)","slug":"trie-sim","description":"Given ops and words arrays of same length, perform operations and return outputs as strings (\"null\" for insert).","visible_skeleton":"func TrieSim(ops []string, words []string) []string {\n\treturn nil\n}\n","test_cases":[{"call":"TrieSim([]string{\"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"}, []string{\"apple\", \"apple\", \"app\", \"app\", \"app\", \"app\"})","expected":"[\"null\", \"true\", \"false\", \"true\", \"null\", \"true\"]"},{"call":"TrieSim([]string{\"insert\", \"startsWith\", \"search\"}, []string{\"hello\", \"he\", \"hello\"})","expected":"[\"null\", \"true\", \"true\"]"},{"call":"TrieSim([]string{\"search\"}, []string{\"nope\"})","expected":"[\"false\"]"},{"call":"TrieSim([]string{\"insert\", \"insert\", \"search\", \"startsWith\"}, []string{\"a\", \"ab\", \"a\", \"abc\"})","expected":"[\"null\", \"null\", \"true\", \"false\"]"},{"call":"TrieSim([]string{\"insert\", \"search\", \"startsWith\", \"startsWith\"}, []string{\"aa\", \"aaa\", \"a\", \"aa\"})","expected":"[\"null\", \"false\", \"true\", \"true\"]"},{"call":"TrieSim([]string{\"insert\", \"insert\", \"insert\", \"search\", \"search\"}, []string{\"dog\", \"deer\", \"deal\", \"dog\", \"de\"})","expected":"[\"null\", \"null\", \"null\", \"true\", \"false\"]"},{"call":"TrieSim([]string{\"startsWith\"}, []string{\"z\"})","expected":"[\"false\"]"},{"call":"TrieSim([]string{\"insert\", \"search\"}, []string{\"x\", \"y\"})","expected":"[\"null\", \"false\"]"},{"call":"TrieSim([]string{\"insert\", \"search\", \"search\"}, []string{\"zoo\", \"zoo\", \"zo\"})","expected":"[\"null\", \"true\", \"false\"]"},{"call":"TrieSim([]string{\"insert\", \"startsWith\"}, []string{\"pre\", \"prefix\"})","expected":"[\"null\", \"false\"]"}]},{"title":"Course Schedule II (Topo Order)","slug":"course-schedule-ii","description":"Return one valid order of courses or empty slice if impossible.","visible_skeleton":"func FindOrder(numCourses int, prerequisites [][]int) []int {\n\treturn nil\n}\n","test_cases":[{"call":"FindOrder(2, [][]int{[]int{1, 0}})","expected":"[0, 1]"},{"call":"FindOrder(4, [][]int{[]int{1, 0}, []int{2, 0}, []int{3, 1}, []int{3, 2}})","expected":"[0, 1, 2, 3]"},{"call":"FindOrder(1, [][]int{})","expected":"[0]"},{"call":"FindOrder(3, [][]int{[]int{1, 0}, []int{1, 2}})","expected":"[0, 2, 1]"},{"call":"FindOrder(3, [][]int{[]int{1, 0}, []int{2, 1}})","expected":"[0, 1, 2]"},{"call":"FindOrder(2, [][]int{[]int{0, 1}, []int{1, 0}})","expected":"[]"},{"call":"FindOrder(5, [][]int{[]int{1, 4}, []int{2, 4}, []int{3, 1}, []int{3, 2}})","expected":"[0, 4, 1, 2, 3]"},{"call":"FindOrder(3, [][]int{})","expected":"[0, 1, 2]"},{"call":"FindOrder(4, [][]int{[]int{0, 1}, []int{0, 2}, []int{1, 2}, []int{2, 3}})","expected":"[3, 2, 1, 0]"},{"call":"FindOrder(6, [][]int{[]int{1, 0}, []int{2, 1}, []int{3, 2}, []int{4, 3}, []int{5, 4}})","expected":"[0, 1, 2, 3, 4, 5]"}]},{"title":"Alien Dictionary (Topo of Characters)","slug":"alien-dictionary","description":"Given sorted words in an alien language, return a possible character order (empty string if invalid).","visible_skeleton":"func AlienOrder(words []string) string {\n\treturn \"\"\n}\n","test_cases":[{"call":"AlienOrder([]string{\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"})","expected":"\"wertf\""},{"call":"AlienOrder([]string{\"z\", \"x\"})","expected":"\"zx\""},{"call":"AlienOrder([]string{\"z\", \"x\", \"z\"})","expected":"\"\""},{"call":"AlienOrder([]string{\"abc\", \"ab\"})","expected":"\"\""},{"call":"AlienOrder([]string{\"abc\", \"abx\", \"abxy\", \"abxyz\"})","expected":"\"abyzcx\""},{"call":"AlienOrder([]string{\"ba\", \"bc\", \"ac\", \"cab\"})","expected":"\"bac\""},{"call":"AlienOrder([]string{\"a\", \"b\", \"c\"})","expected":"\"abc\""},{"call":"AlienOrder([]string{\"ab\", \"adc\"})","expected":"\"acbd\""},{"call":"AlienOrder([]string{\"xza\", \"ayh\", \"ples\", \"plares\", \"plar\"})","expected":"\"\""},{"call":"AlienOrder([]string{\"aa\", \"aa\"})","expected":"\"a\""}]},{"title":"Graph Valid Tree (Union-Find)","slug":"graph-valid-tree","description":"Return true if edges form a valid tree on n nodes.","visible_skeleton":"func ValidTree(n int, edges [][]int) bool {\n\treturn false\n}\n","test_cases":[{"call":"ValidTree(5, [][]int{[]int{0, 1}, []int{0, 2}, []int{0, 3}, []int{1, 4}})","expected":"true"},{"call":"ValidTree(5, [][]int{[]int{0, 1}, []int{1, 2}, []int{2, 3}, []int{1, 3}, []int{1, 4}})","expected":"false"},{"call":"ValidTree(1, [][]int{})","expected":"true"},{"call":"ValidTree(2, [][]int{[]int{0, 1}})","expected":"true"},{"call":"ValidTree(2, [][]int{})","expected":"false"},{"call":"ValidTree(4, [][]int{[]int{0, 1}, []int{2, 3}})","expected":"false"},{"call":"ValidTree(4, [][]int{[]int{0, 1}, []int{1, 2}, []int{2, 3}})","expected":"true"},{"call":"ValidTree(3, [][]int{[]int{0, 1}, []int{1, 2}, []int{2, 0}})","expected":"false"},{"call":"ValidTree(6, [][]int{[]int{0, 1}, []int{1, 2}, []int{2, 3}, []int{3, 4}, []int{4, 5}})","expected":"true"},{"call":"ValidTree(6, [][]int{[]int{0, 1}, []int{2, 3}, []int{3, 4}, []int{4, 2}, []int{5, 0}})","expected":"false"}]},{"title":"Redundant Connection (Union-Find)","slug":"redundant-connection","description":"Given edges of a graph with one extra edge added to a tree, return the redundant edge that creates a cycle.","visible_skeleton":"func RedundantConnection(edges [][]int) []int {\n\treturn nil\n}\n","test_cases":[{"call":"RedundantConnection([][]int{[]int{1, 2}, []int{1, 3}, []int{2, 3}})","expected":"[2, 3]"},{"call":"RedundantConnection([][]int{[]int{1, 2}, []int{2, 3}, []int{3, 4}, []int{1, 4}, []int{1, 5}})","expected":"[1, 4]"},{"call":"RedundantConnection([][]int{[]int{1, 2}, []int{2, 3}, []int{3, 1}})","expected":"[3, 1]"},{"call":"RedundantConnection([][]int{[]int{1, 2}})","expected":"[]"},{"call":"RedundantConnection([][]int{[]int{1, 2}, []int{2, 3}, []int{3, 4}, []int{4, 1}, []int{1, 5}})","expected":"[4, 1]"},{"call":"RedundantConnection([][]int{[]int{1, 2}, []int{3, 4}, []int{1, 3}, []int{2, 4}, []int{2, 3}})","expected":"[2, 4]"},{"call":"RedundantConnection([][]int{[]int{9, 10}, []int{5, 8}, []int{2, 6}, []int{1, 5}, []int{3, 8}, []int{4, 9}, []int{8, 9}})","expected":"[]"},{"call":"RedundantConnection([][]int{[]int{1, 2}, []int{2, 3}, []int{4, 5}, []int{5, 6}, []int{6, 4}})","expected":"[6, 4]"},{"call":"RedundantConnection([][]int{[]int{1, 3}, []int{3, 4}, []int{1, 2}, []int{2, 4}, []int{4, 5}})","expected":"[2, 4]"},{"call":"RedundantConnection([][]int{[]int{1, 2}, []int{1, 3}, []int{2, 3}, []int{3, 4}})","expected":"[2, 3]"}]},{"title":"Longest Consecutive Sequence","slug":"longest-consecutive-seq","description":"Return the length of the longest consecutive sequence.","visible_skeleton":"func LongestConsecutive(nums []int) int {\n\treturn 0\n}\n","test_cases":[{"call":"LongestConsecutive([]int{100,4,200,1,3,2})","expected":"4"},{"call":"LongestConsecutive([]int{0,3,7,2,5,8,4,6,0,1})","expected":"9"},{"call":"LongestConsecutive([]int{})","expected":"0"},{"call":"LongestConsecutive([]int{1})","expected":"1"},{"call":"LongestConsecutive([]int{9,1,4,7,3,-1,0,5,8,-1,6})","expected":"7"},{"call":"LongestConsecutive([]int{1,2,0,1})","expected":"3"},{"call":"LongestConsecutive([]int{10,5,12,3,55,30,4,11,2})","expected":"4"},{"call":"LongestConsecutive([]int{1,3,5,2,4,6,7,8,9})","expected":"9"},{"call":"LongestConsecutive([]int{9,8,7,6,5})","expected":"5"},{"call":"LongestConsecutive([]int{0})","expected":"1"}]},{"title":"Contains Duplicate III (Ordered Set)","slug":"contains-duplicate-iii","description":"Return true if there exist i!=j with |i-j|<=k and |nums[i]-nums[j]|<=t.","visible_skeleton":"func ContainsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\n\treturn false\n}\n","test_cases":[{"call":"ContainsNearbyAlmostDuplicate([]int{1,2,3,1}, 3, 0)","expected":"true"},{"call":"ContainsNearbyAlmostDuplicate([]int{1,5,9,1,5,9}, 2, 3)","expected":"false"},{"call":"ContainsNearbyAlmostDuplicate([]int{1,2}, 0, 1)","expected":"false"},{"call":"ContainsNearbyAlmostDuplicate([]int{1,2}, 1, 0)","expected":"false"},{"call":"ContainsNearbyAlmostDuplicate([]int{1,2,3,1}, 3, 3)","expected":"true"},{"call":"ContainsNearbyAlmostDuplicate([]int{0}, 1, 2)","expected":"false"},{"call":"ContainsNearbyAlmostDuplicate([]int{7,1,3}, 2, 3)","expected":"true"},{"call":"ContainsNearbyAlmostDuplicate([]int{1,2,3,4,5,6}, 2, 2)","expected":"true"},{"call":"ContainsNearbyAlmostDuplicate([]int{1,0,1,1}, 1, 2)","expected":"true"},{"call":"ContainsNearbyAlmostDuplicate([]int{2147483640,2147483641}, 1, 1)","expected":"true"}]},{"title":"Subarray Sum Equals K (Count)","slug":"subarray-sum-equals-k","description":"Return the total number of continuous subarrays whose sum equals k.","visible_skeleton":"func SubarraySumEqualsK(nums []int, k int) int {\n\treturn 0\n}\n","test_cases":[{"call":"SubarraySumEqualsK([]int{1,1,1}, 2)","expected":"2"},{"call":"SubarraySumEqualsK([]int{1,2,3}, 3)","expected":"2"},{"call":"SubarraySumEqualsK([]int{1}, 0)","expected":"0"},{"call":"SubarraySumEqualsK([]int{0,0,0}, 0)","expected":"6"},{"call":"SubarraySumEqualsK([]int{3,4,7,2,-3,1,4,2}, 7)","expected":"4"},{"call":"SubarraySumEqualsK([]int{1,-1,1,-1}, 0)","expected":"4"},{"call":"SubarraySumEqualsK([]int{100,-100,100,-100}, 0)","expected":"4"},{"call":"SubarraySumEqualsK([]int{1,2,1,2,1}, 3)","expected":"4"},{"call":"SubarraySumEqualsK([]int{}, 0)","expected":"0"},{"call":"SubarraySumEqualsK([]int{10,2,-2,-20,10}, -10)","expected":"3"}]},{"title":"Maximum Size Subarray Sum Equals K","slug":"max-size-subarray-sum-k","description":"Return the maximum length of a subarray that sums to k.","visible_skeleton":"func MaxSizeSubarraySumK(nums []int, k int) int {\n\treturn 0\n}\n","test_cases":[{"call":"MaxSizeSubarraySumK([]int{1,-1,5,-2,3}, 3)","expected":"4"},{"call":"MaxSizeSubarraySumK([]int{-2,-1,2,1}, 1)","expected":"2"},{"call":"MaxSizeSubarraySumK([]int{1,1,1,1}, 2)","expected":"2"},{"call":"MaxSizeSubarraySumK([]int{0,0,0}, 0)","expected":"3"},{"call":"MaxSizeSubarraySumK([]int{3,1,-1,1,1,1}, 3)","expected":"5"},{"call":"MaxSizeSubarraySumK([]int{1,-1}, 0)","expected":"2"},{"call":"MaxSizeSubarraySumK([]int{2,-1,2}, 3)","expected":"3"},{"call":"MaxSizeSubarraySumK([]int{1,2,3}, 3)","expected":"2"},{"call":"MaxSizeSubarraySumK([]int{1,2,3}, 7)","expected":"0"},{"call":"MaxSizeSubarraySumK([]int{}, 0)","expected":"0"}]}]}
